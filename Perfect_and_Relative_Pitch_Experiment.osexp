---
API: 2.1
OpenSesame: 3.3.10
Platform: posix
---
set width 1024
set uniform_coordinates yes
set title "SlimStampen example"
set subject_parity even
set subject_nr 0
set start experiment
set sound_sample_size -16
set sound_freq 48000
set sound_channels 2
set sound_buf_size 1024
set sampler_backend psycho
set round_decimals 2
set mouse_backend psycho
set keyboard_backend psycho
set height 768
set fullscreen no
set form_clicks no
set foreground white
set font_underline no
set font_size 18
set font_italic no
set font_family mono
set font_bold no
set experiment_path "/Users/ludivanleeuwen/github/AbsolutePitch-Slimstampen"
set disable_garbage_collection yes
set description "The main experiment item"
set coordinates uniform
set compensation 0
set color_backend psycho
set clock_backend psycho
set canvas_backend psycho
set background black

define inline_script Audio
	set description "Executes Python code"
	___run__
	class Audio:
	    def __init__(self):
	        self.audio = None
	    
	    def play_audio_from_pool(self, file_name: str):
	        src = pool[file_name + '.wav']
	        if len(file_name) < 4: # we are playing a note
	            self.audio = Sampler(src)
	            self.audio.play()
	        else: # we are playing an instrument
	            self.audio = Sampler(src, volume=0.2)
	            self.audio.play()
	        
	    def play_audio_from_frequency(self, frequency: int):
	        self.audio = Synth(freq=frequency, length=1000, attack=0, decay=5)
	        self.audio.play()
	        
	    def play_audio(self, source):
	        print(source, type(source))
	        if type(source) == int:
	            self.play_audio_from_frequency(source)
	        elif type(source) == str:
	            self.play_audio_from_pool(source)
	        elif type(source) == tuple:
	            for i, s in enumerate(source):
	                if i: clock.sleep(1000)
	                self.play_audio(s)
	                
	    def stop_audio(self):
	        self.audio.stop()
	__end__
	set _prepare ""

define sequence ClassDefinitions
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run Text_Style always
	run Display always
	run Audio always
	run Keyboard_Setup_Class always
	run Keyboard_Input always
	run UI_Class always
	run Model_Package always

define inline_script Create_Model_Packages
	set description "Executes Python code"
	___run__
	pitch_masked_package = Model_Package(m_pitch_masked,\
	    facts_pitch_masked, 'pitch_masked', 2, pp_parse_cue)
	pitch_unmasked_package = Model_Package(m_pitch_unmasked,\
	    facts_pitch_unmasked, 'pitch_unmasked', 2, pp_parse_cue)
	interval_masked_package = Model_Package(m_interval_masked,\
	    facts_interval_masked, 'interval_masked', 2, rp_parse_cue)
	interval_unmasked_package = Model_Package(m_interval_unmasked,\
	    facts_interval_unmasked, 'interval_unmasked', 2, rp_parse_cue)
	instrument_pitch_package = Model_Package(m_instruments_pitch,\
	    facts_instruments, 'instrument_pitch')
	instrument_interval_package = Model_Package(m_instruments_interval,\
	    facts_instruments, 'instrument_interval')
	
	print('')
	print('facts per condition:')
	print('pitch_masked:', pitch_masked_package.facts, '\n')
	print('pitch_unmasked:', pitch_unmasked_package.facts, '\n')
	print('interval_masked:', interval_masked_package.facts, '\n')
	print('interval_unmasked:', interval_unmasked_package.facts, '\n')
	print('instruments pitch:', instrument_pitch_package.facts, '\n')
	print('instruments interval:', instrument_interval_package.facts, '\n')
	__end__
	set _prepare ""

define inline_script Cue_Parse_Functions
	set description "Executes Python code"
	___run__
	import random
	
	octave_range_perfect_pitch = (3, 4)
	
	def pp_parse_cue(cue):
	    octave = random.randint(*octave_range_perfect_pitch)
	    pitch = cue + str(octave)
	    return pitch
	
	mod_interval_to_note = ['c', 'c-', 'd', 'd-', 'e', \
	    'f', 'f-', 'g', 'g-', 'a', 'a-', 'b']
	note_to_mod_interval = {note: interval for interval, note \
	                         in enumerate(mod_interval_to_note)}
	
	def interval_c0_to_note(interval_c0):
	    interval_n_octave = interval_c0 // 12
	    interval_mod_octave = interval_c0 % 12
	    
	    note_letter = mod_interval_to_note[interval_mod_octave]
	    note_number = interval_n_octave
	    
	    note = '{}{}'.format(note_letter, note_number)
	    
	    return note
	
	def note_to_interval_c0(note):
	    note_letter, note_number = note[:-1], int(note[-1])
	    
	    interval_c0 = 12 * note_number
	    interval_c0 += note_to_mod_interval[note_letter]
	    
	    return interval_c0
	
	def relative_note(reference_note, interval):
	    ref_interval_c0 = note_to_interval_c0(reference_note)
	    rel_interval_c0 = ref_interval_c0 + interval
	    rel_note = interval_c0_to_note(rel_interval_c0)
	    return rel_note
	
	range_reference_pitch = (note_to_interval_c0('a2'), \
	    note_to_interval_c0('g-4'))
	
	def rp_parse_cue(cue):
	    reference_pitch_i = random.randint(*range_reference_pitch)
	    reference_pitch = interval_c0_to_note(reference_pitch_i)
	    relative_pitch_i = reference_pitch_i + cue
	    relative_pitch = interval_c0_to_note(relative_pitch_i)
	    print('')
	    print('reference_pitch_i', reference_pitch_i)
	    print('reference_pitch', reference_pitch)
	    print('relative_pitch_i', relative_pitch_i)
	    print('relative_pitch', relative_pitch)
	    return (reference_pitch, relative_pitch)
	__end__
	set _prepare ""

define inline_script Display
	set description "Executes Python code"
	___run__
	class Display:
	    answer_style: Text_Style = Text_Style(50, 20, 'White')
	    input_style: Text_Style = Text_Style(100, 20, 'White')
	    feedback_style_positive: Text_Style = Text_Style(150, 20, 'Green')
	    feedback_style_negative: Text_Style = Text_Style(150, 20, 'Red')
	    feedback_style_neutral: Text_Style = Text_Style(150, 20, 'White')
	    
	    def __init__(self):
	        self.answer_text: str = ""
	        self.input_text: str = ""
	        self.feedback_text: str = ""
	        self.feedback_mood: str = "neutral"
	        self.canvas: Canvas = Canvas()
	        
	    def set_answer_text(self, answer_text: str, update_display: bool = True):
	        self.answer_text = answer_text
	        if update_display: self.show()
	        
	    def set_input_text(self, input_text: str, update_display: bool = True):
	        self.input_text = input_text
	        if update_display: self.show()
	        
	    def set_feedback_text(self, feedback_text: str, feedback_mood: str,\
	                          update_display: bool = True):
	        self.feedback_text = feedback_text
	        self.feedback_mood = feedback_mood
	        if update_display: self.show()
	        
	    def clear(self, update_display: bool = True):
	        self.answer_text = ""
	        self.input_text = ""
	        self.feedback_text = ""
	        self.feedback_mood = ""
	        if update_display: self.show()
	        
	    def add_text(self, text: str, style: Text_Style):
	        print('add_text')
	        self.canvas.text(text, y= style.y, \
	                         font_size= style.font_size, color= style.color)
	        
	    def show(self):
	        print('showing screen')
	        self.canvas.clear()
	        
	        if self.answer_text:
	            self.add_text(self.answer_text, self.answer_style)
	        if self.input_text:
	            self.add_text(self.input_text, self.input_style)
	        
	        if self.feedback_text:
	            if self.feedback_mood == 'positive':
	                self.add_text(self.feedback_text,\
	                    self.feedback_style_positive)
	            elif self.feedback_mood == 'negative':
	                self.add_text(self.feedback_text,\
	                    self.feedback_style_negative)
	            elif self.feedback_mood == 'neutral':
	                self.add_text(self.feedback_text,\
	                    self.feedback_style_neutral)
	            else:
	                print('Display: error: unknown feedback mood {}'\
	                    .format(self.feedback_mood))
	                exit(-1)
	            
	        self.canvas.prepare()
	        self.canvas.show()
	__end__
	set _prepare ""

define inline_script Keyboard_Input
	set description "Executes Python code"
	___run__
	class Keyboard_Input:
	    def __init__(self, keyboard_setup: Keyboard_Setup, interface = None):
	        self.keyboard = Keyboard()
	        self.keyboard_setup = keyboard_setup
	        self.interface = interface
	        self.set_to_init_values()
	        
	    def set_to_init_values(self):
	        self.n_presses = 0
	        self.text = ""
	        self.t_first_input = 0
	        self.t_last_empty = 0
	        self.t_return = 0
	        self.has_been_erased_completely = False
	        self.keyboard.flush()
	        
	    def set_interface(self, interface):
	        self.interface = interface
	        
	    def register_times(self, key):
	        t = clock.time()
	        if not self.n_presses and not self.is_ctrl_char(key):
	            self.t_first_input = t
	        if not self.text and not self.is_ctrl_char(key):
	            self.t_last_empty = t
	        if self.is_ctrl_char(key) and \
	            self.keyboard_setup.ctrl_char_mapping[key] == 'return':
	            self.t_return = t
	        
	    def add_char_to_end(self, char):
	        self.text += char
	        
	    def remove_char_from_end(self):
	        if self.text == '': return
	        if len(self.text) == 1: self.has_been_erased_completely = True
	        self.text = self.text[:-1]
	        
	    def is_ctrl_char(self, key: str):
	        return key in self.keyboard_setup.ctrl_char_mapping.keys()
	        
	    def parse_ctrl_char(self, key: str):
	        action = self.keyboard_setup.ctrl_char_mapping[key]
	        
	        if action == 'return':
	            self.is_done = True
	        elif action == 'remove_char_from_end':
	            self.remove_char_from_end()
	        elif action == 'repeat_cue':
	            self.interface.repeat_cue()
	        
	    def parse_char(self, key: str):
	        if key == 'space': self.add_char_to_end(' ')
	        else: self.add_char_to_end(self.keyboard.to_chr(key))
	    
	    def parse_key_press(self, key: str):
	        if self.is_ctrl_char(key): self.parse_ctrl_char(key)
	        else: self.parse_char(key)
	        
	    def take_input(self):
	        self.set_to_init_values()
	        self.is_done = False
	        while not self.is_done:
	            key, _ = self.keyboard.get_key()
	            print(key)
	            self.register_times(key)
	            self.parse_key_press(key)
	            self.interface.display.set_input_text(self.text)
	        return self.text, self.t_first_input, self.has_been_erased_completely
	__end__
	set _prepare ""

define inline_script Keyboard_Setup_Class
	set description "Executes Python code"
	___run__
	class Keyboard_Setup(NamedTuple):
	    ctrl_char_mapping: dict
	__end__
	set _prepare ""

define inline_script Load_Facts
	set description "Executes Python code"
	___run__
	import random
	
	facts_instruments = [Fact(1,"accordeon", "accordeon"),
			 Fact(2,"clarinet", "clarinet"),
		     Fact(3,"drums", "drums"),
			 Fact(4, "electric_guitar", "electric guitar"),
			 Fact(5, "flute", "flute"),
			 Fact(6, "frenchhorn","french horn"),
			 Fact(7, "harmonica", "harmonica"),
			 Fact(8, "harp", "harp"),
			Fact(9, "maraccas", "maraccas"),
			Fact(10, "piano", "piano"),
			Fact(11, "saxophone", "saxophone"),
			Fact(12, "tambourine", "tambourine"),
			Fact(13, "trumpet", "trumpet"),
			Fact(14, "tuba", "tuba"),
			Fact(15, "ukalele", "ukalele"),
			Fact(16, "violin", "violin"),
			Fact(17, "xylophone", "xylophone"),
			Fact(18, "triangle", "triangle")]
			
	random.shuffle(facts_instruments)
	
	def get_two_disjoint_sets(original_set, n_items):
		if n_items > len(original_set) // 2:
			print('get_two_disjoint_sets(): subset size to big to create two disjoint sets')
			print('\tsize of input set:', len(original_set))
			print('\tmaximal size subset:', len(original_set) // 2)
			print('\tn_items:', n_items)
			exit(-1)
		
		shuffled_original_set = random.sample(original_set, len(original_set))
		
		subset_0 = shuffled_original_set[:n_items]
		subset_1 = shuffled_original_set[n_items:2*n_items]
		
		return subset_0, subset_1
		
	facts_pitch = [Fact(1,"c", "c"),
			 Fact(2, "c-", "c sharp"),
			 Fact(3, "d", "d"),
			 Fact(4, "d-", "e flat"),
			 Fact(5, "e", "e"),
			 Fact(6, "f", "f"),
			 Fact(7, "f-", "f sharp"),
			 Fact(8, "g", "g"),
			 Fact(9, "g-", "g sharp"),
			 Fact(10, "a", "a"),
			 Fact(11, "a-", "b flat"),
			 Fact(12, "b", "b")]
	
	facts_interval = []
	
	with open(pool['namedIntervals.csv']) as f:
		lines = f.readlines()
		for i, line in enumerate(lines[1:]):
			cells = line.strip().split(',')
			facts_interval.append(Fact(i, int(cells[1]),\
				str(cells[2]).lower()))
	
	facts_pitch_masked, facts_pitch_unmasked = get_two_disjoint_sets(\
		facts_pitch, len(facts_pitch) // 2)
	facts_interval_masked, facts_interval_unmasked = get_two_disjoint_sets(\
		facts_interval, len(facts_interval) // 2)
	facts_instruments_pitch, facts_instruments_interval = get_two_disjoint_sets(\
		facts_instruments, len(facts_instruments) // 2)
	
	for fact in facts_pitch_masked:
		m_pitch_masked.add_fact(fact)
	for fact in facts_pitch_unmasked:
		m_pitch_unmasked.add_fact(fact)
	for fact in facts_interval_masked:
		m_interval_masked.add_fact(fact)
	for fact in facts_interval_unmasked:
		m_interval_unmasked.add_fact(fact)
	for fact in facts_instruments_pitch:
		m_instruments_pitch.add_fact(fact)
	for fact in facts_instruments_interval:
		m_instruments_interval.add_fact(fact)
	__end__
	set _prepare ""

define inline_script Model_Package
	set description "Executes Python code"
	___run__
	class Model_Package():
	    def __init__(self, \
	                 spacing_model: SpacingModel, \
	                 facts: list, \
	                 condition_name: str, \
	                 n_test_repeats: int = 1, \
	                 cue_parse_function = None):
	        self.spacing_model = spacing_model
	        self.facts = facts
	        self.condition_name = condition_name
	        self.n_test_repeats = n_test_repeats
	        self.cue_parse_function = cue_parse_function
	__end__
	set _prepare ""

define inline_script Run_Item
	set description "Executes Python code"
	___run__
	def run_item(fact, model_package, trial_start_time, \
	             is_masked, learning_or_test, show_answer, \
	             present_feedback):
	    cue = fact.question
	    
	    if model_package.cue_parse_function:
	        cue = model_package.cue_parse_function(cue)
	
	    answer = fact.answer
	    
	    results = ui.present_item(cue, answer, model_package.condition_name, show_answer, present_feedback)
	    
	    rt = results['time'] - trial_start_time \
	    	if not results['response_has_been_erased'] \
	    		else float('inf')
	    		
	    correct = results['correct']
	    user_answer = results['response']
	    
	    response = Response(fact= fact, \
	                        start_time= trial_start_time, \
	                        rt= rt, \
	                        correct= correct, \
	                        condition= model_package.condition_name, \
	                        mask= is_masked, \
	                        test= learning_or_test, \
	                        presented_cue= cue, \
	                        user_answer= user_answer)
	    
	    model_package.spacing_model.register_response(response) 
	    
	    if present_feedback: clock.sleep(var.feedback_duration)
	    
	    # Clear the screen between trials
	    ui.clear_screen()
	    
	    clock.sleep(var.inter_trial_interval)
	    	
	    # Increment trial number
	    var.trial_num += 1
	
	def run_learning_item(model_package, is_masked):
	    trial_start_time = clock.time()
	    learning_fact, is_new = \
		model_package.spacing_model.get_next_fact(current_time = \
								trial_start_time)
	    run_item(learning_fact, model_package, trial_start_time, \
	             is_masked, 'learning', is_new, True)
	
	
	def run_test_item(model_package, test_fact, is_masked):
	    trial_start_time = clock.time()
	    run_item(test_fact, model_package, trial_start_time, \
	             is_masked, 'test', False, False)
	    
	def run_masked_learning(mask_package, other_package):
	    end_time = clock.time() + var.session_duration
	    
	    while clock.time() < end_time:
	        run_learning_item(mask_package, True)
	        run_learning_item(other_package, True)
	        
	def run_unmasked_learning(other_package):
	    end_time = clock.time() + var.session_duration
	    
	    while clock.time() < end_time:
	        run_learning_item(other_package, False)
	        
	def run_masked_test(mask_package, other_package):
	    n_facts = other_package.n_test_repeats * len(other_package.facts)
	    
	    n_full_repeats_mask = n_facts // len(mask_package.facts)
	    n_mask_items_repeated_one_more_time = n_facts % \
	        len(mask_package.facts)
	    
	    mask_facts = n_full_repeats_mask * mask_package.facts + \
	        random.sample(mask_package.facts, \
	            n_mask_items_repeated_one_more_time)
	    mask_facts = random.sample(mask_facts, len(mask_facts))
	    
	    other_facts = random.sample(other_package.n_test_repeats * other_package.facts, \
	        n_facts)
	    
	    for i in range(n_facts):
	        run_test_item(mask_package, mask_facts[i], True)
	        run_test_item(other_package, other_facts[i], True)
	        
	def run_unmasked_test(other_package):
	    other_facts = other_package.n_test_repeats * other_package.facts
	    
	    n_facts = len(other_facts)
	    
	    other_facts = random.sample(other_facts, n_facts)
	    
	    for i in range(n_facts):
	        run_test_item(other_package, other_facts[i], False)
	__end__
	set _prepare ""

define inline_script Text_Style
	set description "Executes Python code"
	___run__
	from typing import NamedTuple
	
	class Text_Style(NamedTuple):
	    y: int
	    font_size: int
	    color: str
	__end__
	set _prepare ""

define sequence UI
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run ClassDefinitions always
	run UsefulFunctions always
	run UI_Setup always

define inline_script UI_Class
	set description "Executes Python code"
	___run__
	class UI:
	    class Item_State():
	        cue: str = ''
	        answer: str = ''
	        response: str = ''
	        response_has_been_erased: bool = False
	        time: float = float('inf')
	        correct: bool = False
	        
	        def as_dict(self):
	            return {'cue': self.cue,
	                    'answer': self.answer,
	                    'response': self.response,
	                    'response_has_been_erased': self.response_has_been_erased,
	                    'time': self.time,
	                    'correct': self.correct
	            }
	        
	    def __init__(self, display: Display = None, audio: Audio = None,
	                 keyboard: Keyboard_Input = None):
	        self.display: Display = display if display else Display()
	        self.audio: Audio = audio if audio else Audio()
	        self.keyboard: Keyboard_Input = keyboard \
	            if keyboard else Keyboard_Input()
	        self.keyboard.set_interface(self)
	        
	        self.set_to_init_values()
	    
	    def set_to_init_values(self):
	        self.item_state = UI.Item_State()
	        
	    def clear_screen(self):
	        self.display.clear()
	
	    def present_cue(self):
	        self.audio.play_audio(self.state.cue)
	        
	    def show_answer(self):
	        self.display.set_answer_text(self.state.answer)
	        
	    def repeat_cue(self):
	        self.present_cue()
	        
	    def find_edit_distance(self, s1, s2): # from "https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#Python"
	        if len(s1) < len(s2):
	            return self.find_edit_distance(s2, s1)
	        if len(s2) == 0:
	            return len(s1)
	        previous_row = range(len(s2) + 1)
	        for i, c1 in enumerate(s1):
	            current_row = [i + 1]
	            for j, c2 in enumerate(s2):
	                insertions = previous_row[j + 1] + 1
	                deletions = current_row[j] + 1       
	                substitutions = previous_row[j] + (c1 != c2)
	                current_row.append(min(insertions, deletions, substitutions))
	            previous_row = current_row
	        
	        return previous_row[-1]
	    
	    def check_response(self, condition):
	        if self.state.response == self.state.answer:
	            self.state.correct = True
	        else:
	            if condition == 'pitch_masked' or condition == 'pitch_unmasked': # here you cannot make a mistake as the edit distance between e and b is 1:
	                self.state.correct = False
	            else:
	                if self.find_edit_distance(self.state.response, self.state.answer) < 3:    # only check edit distance if not immediately clear.
	                    self.state.correct = True
	                else:
	                    self.state.correct = False
	            
	        
	    def take_input(self):
	        self.state.response, self.state.time, \
	            self.state.response_has_been_erased = \
	                self.keyboard.take_input()
	    
	    def present_feedback(self):
	        if self.state.correct:
	            feedback_text = 'correct'
	            feedback_mood = 'positive'
	        else:
	            feedback_text = self.state.answer
	            feedback_mood = 'negative'
	            
	        self.display.set_feedback_text(feedback_text, feedback_mood)
	        
	    def set_cue_answer(self, cue, answer):
	        self.state = UI.Item_State()
	        self.state.cue = cue
	        self.state.answer = answer
	        
	    def present_item(self, cue, answer, condition, show_answer: bool = False, \
	                     present_feedback: bool = True):
	        self.set_cue_answer(cue, answer)
	        self.clear_screen()
	        if show_answer: self.show_answer()
	        self.present_cue()
	        self.take_input()
	        self.audio.stop_audio()
	        self.check_response(condition)
	        if present_feedback: self.present_feedback()
	        return self.state.as_dict()
	        
	__end__
	set _prepare ""

define inline_script UI_Setup
	set description "Executes Python code"
	___run__
	ks = Keyboard_Setup({'return': 'return',\
	                     'backspace': 'remove_char_from_end',\
	                     '1': 'repeat_cue'})
	ki = Keyboard_Input(ks)
	ui = UI(keyboard = ki)
	__end__
	set _prepare ""

define sequence UsefulFunctions
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run Cue_Parse_Functions always
	run Run_Item always

define sketchpad change_group_to_interval_no_mask
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Now changing to intervals no masking" x=0 y=0 z_index=0

define sketchpad change_group_to_pitch_no_mask
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Going into Single note no masking" x=0 y=0 z_index=0

define sequence experiment
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run slimstampen_setup always
	run UI always
	run Load_Facts always
	run Create_Model_Packages always
	run instructions always
	run learning_session_setup always
	run pitch_w_mask_sequence always
	run pitch_wo_mask_sequence always
	run switching_to_intervals always
	run interval_w_mask_sequence always
	run interval_wo_mask_sequence always
	run save_data always

define sketchpad instructions
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Instructions go here. Press any key to begin." x=0 y=-32 z_index=0
	draw textline center=1 color="#fd8008" font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Press 1 to repeat the fact" x=0 y=0 z_index=0

define inline_script interval_w_mask_learning_script
	set description "Executes Python code"
	set _run "run_masked_learning(instrument_interval_package, interval_masked_package)"
	set _prepare ""

define sequence interval_w_mask_sequence
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run training_instructions always
	run interval_w_mask_learning_script always
	run testing_instructions always
	run interval_w_mask_test_script always

define inline_script interval_w_mask_test_script
	set description "Executes Python code"
	set _run "run_masked_test(instrument_interval_package, interval_masked_package)"
	set _prepare ""

define inline_script interval_wo_mask_learning_script
	set description "Executes Python code"
	set _run "run_unmasked_learning(interval_unmasked_package)"
	set _prepare ""

define sequence interval_wo_mask_sequence
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run change_group_to_interval_no_mask always
	run training_instructions always
	run interval_wo_mask_learning_script always
	run testing_instructions always
	run interval_wo_mask_test_script always

define inline_script interval_wo_mask_test_script
	set description "Executes Python code"
	set _run "run_unmasked_test(interval_unmasked_package)"
	set _prepare ""

define inline_script learning_session_setup
	set description "Executes Python code"
	___run__
	# Start the clock
	var.session_start_time = clock.time()
	
	# Session will run until time_up == True
	var.time_up = False
	
	# Keep track of trial number
	var.trial_num = 1
	
	# Settings
	var.session_duration = 5000
	var.feedback_duration = 800
	var.inter_trial_interval = 200
	
	## testing phase
	var.end = False
	__end__
	set _prepare ""

define inline_script pitch_w_mask_learning_script
	set description "Executes Python code"
	set _run "run_masked_learning(instrument_pitch_package, pitch_masked_package)"
	set _prepare ""

define sequence pitch_w_mask_sequence
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run training_instructions always
	run pitch_w_mask_learning_script always
	run testing_instructions always
	run pitch_w_mask_test_script always

define inline_script pitch_w_mask_test_script
	set description "Executes Python code"
	set _run "run_masked_test(instrument_pitch_package, pitch_masked_package)"
	set _prepare ""

define inline_script pitch_wo_mask_learning_script
	set description "Executes Python code"
	set _run "run_unmasked_learning(pitch_unmasked_package)"
	set _prepare ""

define sequence pitch_wo_mask_sequence
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run change_group_to_pitch_no_mask always
	run training_instructions always
	run pitch_wo_mask_learning_script always
	run testing_instructions always
	run pitch_wo_mask_test_script always

define inline_script pitch_wo_mask_test_script
	set description "Executes Python code"
	set _run "run_unmasked_test(pitch_unmasked_package)"
	set _prepare ""

define inline_script save_data
	set description "Executes Python code"
	___run__
	# Write the SlimStampen data to the OpenSesame log file
	dat = pitch_masked_package.spacing_model.export_data(header_true=True)
	dat1 = pitch_unmasked_package.spacing_model.export_data(header_true=False)
	dat2 = interval_masked_package.spacing_model.export_data(header_true = False)
	dat3 = interval_unmasked_package.spacing_model.export_data(header_true = False)
	dat4 = instrument_pitch_package.spacing_model.export_data(header_true = False)
	dat5 = instrument_interval_package.spacing_model.export_data(header_true = False)
	
	log.write(dat)
	log.write(dat1)
	log.write(dat2)
	log.write(dat3)
	log.write(dat4)
	log.write(dat5)
	__end__
	set _prepare ""

define inline_script slimstampen_setup
	set description "Executes Python code"
	___run__
	m_pitch_unmasked = SpacingModel()
	m_pitch_masked = SpacingModel()
	m_interval_unmasked = SpacingModel()
	m_interval_masked = SpacingModel()
	m_instruments_pitch = SpacingModel()
	m_instruments_interval = SpacingModel()
	__end__
	___prepare__
	from __future__ import division
	import math
	import pandas as pd
	from collections import namedtuple
	
	Fact = namedtuple("Fact", "fact_id, question, answer")
	Response = namedtuple("Response", "fact, start_time, rt, correct, condition, mask, test, presented_cue, user_answer")
	Encounter = namedtuple("Encounter", "activation, time, reaction_time, decay")
	
	
	class SpacingModel(object):
	
	    # Model constants
	    LOOKAHEAD_TIME = 15000
	    FORGET_THRESHOLD = -0.8
	    DEFAULT_ALPHA = 0.3
	    C = 0.25
	    F = 1.0
	
	    def __init__(self):
	        self.facts = []
	        self.responses = []
	
	    def add_fact(self, fact):
	        # type: (Fact) -> None
	        """
	        Add a fact to the list of study items.
	        """
	        # Ensure that a fact with this ID does not exist already
	        if next((f for f in self.facts if f.fact_id == fact.fact_id), None):
	            raise RuntimeError(
	                "Error while adding fact: There is already a fact with the same ID: {}. Each fact must have a unique ID".format(fact.fact_id))
	
	        self.facts.append(fact)
	
	
	    def register_response(self, response):
	        # type: (Response) -> None
	        """
	        Register a response.
	        """
	        # Prevent duplicate responses
	        if next((r for r in self.responses if r.start_time == response.start_time), None):
	            raise RuntimeError(
	                "Error while registering response: A response has already been logged at this start_time: {}. Each response must occur at a unique start_time.".format(response.start_time))
	
	        self.responses.append(response)
	
	
	    def get_next_fact(self, current_time):
	        # type: (int) -> (Fact, bool)
	        """
	        Returns a tuple containing the fact that needs to be repeated most urgently and a boolean indicating whether this fact is new (True) or has been presented before (False).
	        If none of the previously studied facts needs to be repeated right now, return a new fact instead.
	        """
	        # Calculate all fact activations in the near future
	        fact_activations = [(f, self.calculate_activation(current_time + self.LOOKAHEAD_TIME, f)) for f in self.facts]
	
	        seen_facts = [(f, a) for (f, a) in fact_activations if a > -float("inf")]
	        not_seen_facts = [(f, a) for (f, a) in fact_activations if a == -float("inf")]
	
	        # Prevent an immediate repetition of the same fact
	        if len(seen_facts) > 2:
	            last_response = self.responses[-1]
	            seen_facts = [(f, a) for (f, a) in seen_facts if f.fact_id != last_response.fact.fact_id]
	
	        # Reinforce the weakest fact with an activation below the threshold
	        seen_facts_below_threshold = [(f, a) for (f, a) in seen_facts if a < self.FORGET_THRESHOLD]
	        if len(not_seen_facts) == 0 or len(seen_facts_below_threshold) > 0:
	            weakest_fact = min(seen_facts, key = lambda t: t[1])
	            return((weakest_fact[0], False))
	
	        # If none of the previously seen facts has an activation below the threshold, return a new fact
	        return((not_seen_facts[0][0], True))
	
	
	    def get_rate_of_forgetting(self, time, fact):
	        # type: (int, Fact) -> float
	        """
	        Return the estimated rate of forgetting of the fact at the specified time
	        """
	        encounters = []
	
	        responses_for_fact = [r for r in self.responses if r.fact.fact_id == fact.fact_id and r.start_time < time]
	        alpha = self.DEFAULT_ALPHA
	
	        # Calculate the activation by running through the sequence of previous responses
	        for response in responses_for_fact:
	            activation = self.calculate_activation_from_encounters(encounters, response.start_time)
	            encounters.append(Encounter(activation, response.start_time, self.normalise_reaction_time(response), self.DEFAULT_ALPHA))
	            alpha = self.estimate_alpha(encounters, activation, response, alpha)
	
	            # Update decay estimates of previous encounters
	            encounters = [encounter._replace(decay = self.calculate_decay(encounter.activation, alpha)) for encounter in encounters]
	
	        return(alpha)
	
	
	    def calculate_activation(self, time, fact):
	        # type: (int, Fact) -> float
	        """
	        Calculate the activation of a fact at the given time.
	        """
	
	        encounters = []
	
	        responses_for_fact = [r for r in self.responses if r.fact.fact_id == fact.fact_id and r.start_time < time]
	        alpha = self.DEFAULT_ALPHA
	
	        # Calculate the activation by running through the sequence of previous responses
	        for response in responses_for_fact:
	            activation = self.calculate_activation_from_encounters(encounters, response.start_time)
	            encounters.append(Encounter(activation, response.start_time, self.normalise_reaction_time(response), self.DEFAULT_ALPHA))
	            alpha = self.estimate_alpha(encounters, activation, response, alpha)
	
	            # Update decay estimates of previous encounters
	            encounters = [encounter._replace(decay = self.calculate_decay(encounter.activation, alpha)) for encounter in encounters]
	
	        return(self.calculate_activation_from_encounters(encounters, time))
	
	
	    def calculate_decay(self, activation, alpha):
	        # type: (float, float) -> float
	        """
	        Calculate activation-dependent decay
	        """
	        return self.C * math.exp(activation) + alpha
	
	
	    def estimate_alpha(self, encounters, activation, response, previous_alpha):
	        # type: ([Encounter], float, Response, float) -> float
	        """
	        Estimate the rate of forgetting parameter (alpha) for an item.
	        """
	        if len(encounters) < 3:
	            return(self.DEFAULT_ALPHA)
	
	        a_fit = previous_alpha
	        reading_time = self.get_reading_time(response.fact.question)
	        estimated_rt = self.estimate_reaction_time_from_activation(activation, reading_time)
	        est_diff = estimated_rt - self.normalise_reaction_time(response)
	
	        if est_diff < 0:
	            # Estimated RT was too short (estimated activation too high), so actual decay was larger
	            a0 = a_fit
	            a1 = a_fit + 0.05
	        
	        else:
	            # Estimated RT was too long (estimated activation too low), so actual decay was smaller
	            a0 = a_fit - 0.05
	            a1 = a_fit
	
	        # Binary search between previous fit and proposed alpha
	        for _ in range(6):
	            # Adjust all decays to use the new alpha
	            a0_diff = a0 - a_fit
	            a1_diff = a1 - a_fit
	            d_a0 = [e._replace(decay = e.decay + a0_diff) for e in encounters]
	            d_a1 = [e._replace(decay = e.decay + a1_diff) for e in encounters]
	
	            # Calculate the reaction times from activation and compare against observed RTs
	            encounter_window = encounters[max(1, len(encounters) - 5):]
	            total_a0_error = self.calculate_predicted_reaction_time_error(encounter_window, d_a0, reading_time)
	            total_a1_error = self.calculate_predicted_reaction_time_error(encounter_window, d_a1, reading_time)
	
	            # Adjust the search area based on the lowest total error
	            ac = (a0 + a1) / 2
	            if total_a0_error < total_a1_error:
	                a1 = ac
	            else:
	                a0 = ac
	        
	        # The new alpha estimate is the average value in the remaining bracket
	        return((a0 + a1) / 2)
	
	
	    def calculate_activation_from_encounters(self, encounters, current_time):
	        # type: ([Encounter], int) -> float
	        included_encounters = [e for e in encounters if e.time < current_time]
	
	        if len(included_encounters) == 0:
	            return(-float("inf"))
	
	        return(math.log(sum([math.pow((current_time - e.time) / 1000, -e.decay) for e in included_encounters])))
	
	
	    def calculate_predicted_reaction_time_error(self, test_set, decay_adjusted_encounters, reading_time):
	        # type: ([Encounter], [Encounter], Fact) -> float
	        """
	        Calculate the summed absolute difference between observed response times and those predicted based on a decay adjustment.
	        """
	        activations = [self.calculate_activation_from_encounters(decay_adjusted_encounters, e.time - 100) for e in test_set]
	        rt = [self.estimate_reaction_time_from_activation(a, reading_time) for a in activations]
	        rt_errors = [abs(e.reaction_time - rt) for (e, rt) in zip(test_set, rt)]
	        return(sum(rt_errors))
	
	
	    def estimate_reaction_time_from_activation(self, activation, reading_time):
	        # type: (float, int) -> float
	        """
	        Calculate an estimated reaction time given a fact's activation and the expected reading time 
	        """
	        return((self.F * math.exp(-activation) + (reading_time / 1000)) * 1000)
	
	
	    def get_max_reaction_time_for_fact(self, fact):
	        # type: (Fact) -> float
	        """
	        Return the highest response time we can reasonably expect for a given fact
	        """
	        reading_time = self.get_reading_time(fact.question)
	        max_rt = 1.5 * self.estimate_reaction_time_from_activation(self.FORGET_THRESHOLD, reading_time)
	        return(max_rt)
	
	
	    def get_reading_time(self, text):
	        # type: (str) -> float
	        """
	        Return expected reading time in milliseconds for a given string
	        """
	        return 0.0
	        word_count = len(text.split())
	
	        if word_count > 1:
	            character_count = len(text)
	            return(max((-157.9 + character_count * 19.5), 300))
	        
	        return(300)
	
	    
	    def normalise_reaction_time(self, response):
	        # type: (Response) -> float
	        """
	        Cut off extremely long responses to keep the reaction time within reasonable bounds
	        """
	        rt = response.rt if response.correct else 60000
	        max_rt = self.get_max_reaction_time_for_fact(response.fact)
	        return(min(rt, max_rt))
	
	
	    def export_data(self, path = None, header_true = True):
	        # type: (str) -> DataFrame
	        """
	        Save the response data to the specified csv file, and return a copy of the pandas DataFrame.
	        If no path is specified, return a CSV-formatted copy of the data instead.
	        """
	
	        def calc_rof(row):
	            return(self.get_rate_of_forgetting(row["start_time"] + 1, row["fact"]))
	
	        dat_resp = pd.DataFrame(self.responses)
	        dat_facts = pd.DataFrame([r.fact for r in self.responses])
	        dat = pd.concat([dat_resp, dat_facts], axis = 1)
	
	        # Add column for rate of forgetting estimate after each observation
	        dat["alpha"] = dat.apply(calc_rof, axis = 1)
	        dat.drop(columns = "fact", inplace = True)
	
	        # Add trial number column
	        dat.index.name = "trial"
	        dat.index = dat.index + 1
	            
	
	        # Save to CSV file if a path was specified, otherwise return the CSV-formatted output
	        if path is not None:
	            dat.to_csv(path, header=header_true, encoding="UTF-8")
	            return(dat)
	        
	        return(dat.to_csv(header=header_true))
	__end__

define sketchpad switching_to_intervals
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Now starting Interval conditions" x=0 y=0 z_index=0

define sketchpad testing_instructions
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Testing phase begins now<br />Press any key to continue<br /><br />" x=0 y=0 z_index=0

define sketchpad training_instructions
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color="#fec52d" font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Starting training block... <br />press any key to continue, when you're ready" x=0 y=0 z_index=0

