---
API: 2.1
OpenSesame: 3.3.10
Platform: nt
---
set width 1024
set uniform_coordinates yes
set title "SlimStampen example"
set subject_parity even
set subject_nr 0
set start experiment
set sound_sample_size -16
set sound_freq 48000
set sound_channels 2
set sound_buf_size 1024
set sampler_backend psycho
set round_decimals 2
set mouse_backend psycho
set keyboard_backend psycho
set height 768
set fullscreen no
set form_clicks no
set foreground white
set font_underline no
set font_size 18
set font_italic no
set font_family mono
set font_bold no
set experiment_path "C:\\Users\\Gebruiker\\Documents\\University\\User_Models\\Other\\AbsolutePitch-Slimstampen"
set disable_garbage_collection yes
set description "The main experiment item"
set coordinates uniform
set compensation 0
set color_backend psycho
set clock_backend psycho
set canvas_backend psycho
set background black

define inline_script Audio
	set description "Executes Python code"
	___run__
	class Audio:
	    def __init__(self):
	        self.audio = None
	    
	    def play_audio_from_pool(self, file_name: str):
	        src = pool[file_name + '.wav']
	        self.audio = Sampler(src)
	        self.audio.play()
	        
	    def play_audio_from_frequency(self, frequency: int):
	        self.audio = Synth(freq=frequency, length=1000, attack=0, decay=5)
	        self.audio.play()
	        
	    def play_audio(self, source):
	        print(source, type(source))
	        if type(source) == int:
	            self.play_audio_from_frequency(source)
	        elif type(source) == str:
	            self.play_audio_from_pool(source)
	        elif type(source) == tuple:
	            for i, s in enumerate(source):
	                if i: clock.sleep(1000)
	                self.play_audio(s)
	                
	    def stop_audio(self):
	        self.audio.stop()
	__end__
	set _prepare ""

define sketchpad Change_intervals_conditions
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Now changing to intervals no masking" x=0 y=0 z_index=0

define sequence ClassDefinitions
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run Text_Style always
	run Display always
	run Audio always
	run Keyboard_Setup_Class always
	run Keyboard_Input always
	run UI_Class always
	run Model_Package always

define inline_script Class_Struggle
	set description "Executes Python code"
	___run__
	from typing import NamedTuple
	
	class Text_Style(NamedTuple):
	    y: int
	    font_size: int
	    color: str
	
	class Display:
	    answer_style: Text_Style = Text_Style(50, 20, 'White')
	    input_style: Text_Style = Text_Style(100, 20, 'White')
	    feedback_style_positive: Text_Style = Text_Style(150, 20, 'Green')
	    feedback_style_negative: Text_Style = Text_Style(150, 20, 'Red')
	    feedback_style_neutral: Text_Style = Text_Style(150, 20, 'White')
	    
	    def __init__(self):
	        print('creating display')
	        self.answer_text: str = ""
	        self.input_text: str = ""
	        self.feedback_text: str = ""
	        self.feedback_mood: str = "neutral"
	        self.canvas: Canvas = Canvas()
	        
	    def set_answer_text(self, answer_text: str, update_display: bool = True):
	        self.answer_text = answer_text
	        if update_display: self.show()
	        
	    def set_input_text(self, input_text: str, update_display: bool = True):
	        self.input_text = input_text
	        if update_display: self.show()
	        
	    def set_feedback_text(self, feedback_text: str, feedback_mood: str,\
	                          update_display: bool = True):
	        self.feedback_text = feedback_text
	        self.feedback_mood = feedback_mood
	        if update_display: self.show()
	        
	    def clear_screen(self, update_display: bool = True):
	        self.answer_text = ""
	        self.input_text = ""
	        self.feedback_text = ""
	        self.feedback_mood = ""
	        if update_display(): self.show()
	        
	    def add_text(self, text: str, style: Text_Style):
	        print('add_text')
	        self.canvas.text(text, y= style.y, \
	                         font_size= style.font_size, color= style.color)
	        
	    def show(self):
	        print('showing screen')
	        self.canvas.clear()
	        
	        if self.answer_text:
	            self.add_text(self.answer_text, self.answer_style)
	        if self.input_text:
	            self.add_text(self.input_text, self.input_style)
	        
	        if self.feedback_text:
	            if self.feedback_mood == 'positive':
	                self.add_text(self.feedback_text,\
	                    self.feedback_style_positive)
	            elif self.feedback_mood == 'negative':
	                self.add_text(self.feedback_text,\
	                    self.feedback_style_negative)
	            elif self.feedback_mood == 'neutral':
	                self.add_text(self.feedback_text,\
	                    self.feedback_style_neutral)
	            else:
	                print('Display: error: unknown feedback mood {}'\
	                    .format(self.feedback_mood))
	                exit(-1)
	            
	        self.canvas.prepare()
	        self.canvas.show()
	
	class Audio:
	    def __init__(self):
	        pass
	    
	    def play_sound_from_pool(self, filename: str):
	        src = pool[file_name]
	        Sampler(src).play()
	        
	
	class Keyboard_Setup(NamedTuple):
	    ctrl_char_mapping: dict
	
	class Keyboard_Input:
	    def __init__(self, keyboard_setup: Keyboard_Setup, interface = None):
	        print('create keyboard')
	        self.keyboard = Keyboard()
	        self.keyboard_setup = keyboard_setup
	        self.interface = interface
	        self.set_to_init_values()
	        
	    def set_to_init_values(self):
	        self.n_presses = 0
	        self.text = ""
	        self.t_first_input = 0
	        self.t_last_empty = 0
	        self.t_return = 0
	        
	    def set_interface(self, interface):
	        self.interface = interface
	        
	    def register_times(self, key):
	        t = clock.time()
	        if not self.n_presses and not self.is_ctrl_char(key):
	            self.t_first_input = t
	        if not self.text and not self.is_ctrl_char(key):
	            self.t_last_empty = t
	        if self.is_ctrl_char(key) and \
	            self.keyboard_setup.ctrl_char_mapping[key] == 'return':
	            self.t_return = t
	        
	    def add_char_to_end(self, char):
	        self.text += char
	        
	    def remove_char_from_end(self):
	        if self.text == '': return
	        self.text = self.text[:-1]
	        
	    def is_ctrl_char(self, key: str):
	        return key in self.keyboard_setup.ctrl_char_mapping.keys()
	        
	    def parse_ctrl_char(self, key: str):
	        action = self.keyboard_setup.ctrl_char_mapping[key]
	        
	        if action == 'return':
	            self.is_done = True
	        elif action == 'remove_char_from_end':
	            self.remove_char_from_end()
	        elif action == 'repeat_cue':
	            pass
	        
	    def parse_char(self, key: str):
	        if key == 'space': self.add_char_to_end(' ')
	        else: self.add_char_to_end(self.keyboard.to_chr(key))
	    
	    def parse_key_press(self, key: str):
	        if self.is_ctrl_char(key): self.parse_ctrl_char(key)
	        else: self.parse_char(key)
	        
	    def take_input(self):
	        self.is_done = False
	        while not self.is_done:
	            key, _ = self.keyboard.get_key()
	            print(key)
	            self.register_times(key)
	            self.parse_key_press(key)
	            self.interface.display.set_input_text(self.text)
	        return self.text, self.t_first_input
	
	
	
	
	
	
	
	
	class UI:
	    def __init__(self, display: Display = None, audio: Audio = None,
	                 keyboard: Keyboard_Input = None):
	        print('creating ui')
	        self.display: Display = display if display else Display()
	        self.audio: Audio = audio if audio else Audio()
	        self.keyboard: Keyboard_Input = keyboard.set_interface(self)\
	            if keyboard else Keyboard_Input(self)
	
	class Experiment:
	    def __init__(self, interface, input_name):
	        self.interface = interface
	        self.spacing_model = SpacingModel()
	        self.load_csv(self.spacing_model, input_name)
	        
	        
	    def load_csv(self, model, input_):
	        items_ = []
	        if 'csv' in input_:
	            with open(pool[input_]) as f:
	                lines = f.readlines()
	                for i, line in enumerate(lines[1:]):
	                    cells = line.split(',')
	                    items_.append(Fact(i, cells[1], str(cells[2]).lower()))
	        else:
	            items_ = input_
	        random.shuffle(items_)
	        for item in items_:
	            model.add_fact(item)
	            
	        
	    def get_next_item(self):
	        self.item = self.spacing_model.get_next_fact( \
	                        current_time = self.current_trial_start_time)
	        return self.item
	    
	    def present_cue(self):
	        self.interface.play_audio(self.item.question)
	        # if self.item.cue.cue_type == 'audio':
	        #     self.output.play_audio(self.cue.text)
	        # elif self.item.cue.cue_type == 'text':
	        #     text = Text(self.item.cue.text, 50)
	        #     self.output.show_texts_on_screen([text])
	    
	    def show_correct_answer(self):
	        text = Text(item.correct_answer, y= 50)
	        self.output.show_texts_on_canvas([text])
	        
	    def get_iteration_statistics(self):
	        iteration_statistics = {
	            'cue': self.item.cue, \
	            'answer': self.item.answer, \
	            'response': self.response, \
	            'correct': self.correct, \
	            'response_time': self.rt
	            }
	        return iteration_statistics
	    
	    def run_one_item(self):
	        self.current_trial_start_time = clock.time()
	        self.get_next_item()
	        self.present_cue()
	        if item.first_presentation: self.show_correct_answer()
	        self.response, self.rt = self.interface.get_text_input()
	        self.correct = self.response == self.cue.answer
	        return self.get_iteration_statistics()
	__end__
	set _prepare ""

define inline_script Create_Model_Packages
	set description "Executes Python code"
	___run__
	pitch_package = Model_Package(m, facts, 'pitch')
	interval_package = Model_Package(m_relative, facts_relative, 'interval', rp_parse_cue)
	instrument_package = Model_Package(m_instruments, facts_instruments, 'instrument')
	__end__
	set _prepare ""

define inline_script Cue_Parse_Function_Relative_Pitch
	set description "Executes Python code"
	___run__
	mod_interval_to_note = ['c', 'c-', 'd', 'd-', 'e', \
	    'f', 'f-', 'g', 'g-', 'a', 'a-', 'b']
	note_to_mod_interval = {note: interval for interval, note \
	                         in enumerate(mod_interval_to_note)}
	
	def interval_c0_to_note(interval_c0):
	    interval_n_octave = interval_c0 // 12
	    interval_mod_octave = interval_c0 % 12
	    
	    note_letter = mod_interval_to_note[interval_mod_octave]
	    note_number = interval_n_octave
	    
	    note = '{}{}'.format(note_letter, note_number)
	    
	    return note
	
	def note_to_interval_c0(note):
	    note_letter, note_number = note[:-1], int(note[-1])
	    
	    interval_c0 = 12 * note_number
	    interval_c0 += note_to_mod_interval[note_letter]
	    
	    return interval_c0
	
	def relative_note(reference_note, interval):
	    ref_interval_c0 = note_to_interval_c0(reference_note)
	    rel_interval_c0 = ref_interval_c0 + interval
	    rel_note = interval_c0_to_note(rel_interval_c0)
	    return rel_note
	
	range_reference_pitch = (note_to_interval_c0('c3'), \
	    note_to_interval_c0('c5'))
	
	import random
	
	def rp_parse_cue(cue):
	    reference_pitch_i = random.randint(*range_reference_pitch)
	    reference_pitch = interval_c0_to_note(reference_pitch_i)
	    relative_pitch_i = reference_pitch_i + cue
	    relative_pitch = interval_c0_to_note(relative_pitch_i)
	    print('')
	    print('reference_pitch_i', reference_pitch_i)
	    print('reference_pitch', reference_pitch)
	    print('relative_pitch_i', relative_pitch_i)
	    print('relative_pitch', relative_pitch)
	    return (reference_pitch, relative_pitch)
	__end__
	set _prepare ""

define inline_script Display
	set description "Executes Python code"
	___run__
	class Display:
	    answer_style: Text_Style = Text_Style(50, 20, 'White')
	    input_style: Text_Style = Text_Style(100, 20, 'White')
	    feedback_style_positive: Text_Style = Text_Style(150, 20, 'Green')
	    feedback_style_negative: Text_Style = Text_Style(150, 20, 'Red')
	    feedback_style_neutral: Text_Style = Text_Style(150, 20, 'White')
	    
	    def __init__(self):
	        self.answer_text: str = ""
	        self.input_text: str = ""
	        self.feedback_text: str = ""
	        self.feedback_mood: str = "neutral"
	        self.canvas: Canvas = Canvas()
	        
	    def set_answer_text(self, answer_text: str, update_display: bool = True):
	        self.answer_text = answer_text
	        if update_display: self.show()
	        
	    def set_input_text(self, input_text: str, update_display: bool = True):
	        self.input_text = input_text
	        if update_display: self.show()
	        
	    def set_feedback_text(self, feedback_text: str, feedback_mood: str,\
	                          update_display: bool = True):
	        self.feedback_text = feedback_text
	        self.feedback_mood = feedback_mood
	        if update_display: self.show()
	        
	    def clear(self, update_display: bool = True):
	        self.answer_text = ""
	        self.input_text = ""
	        self.feedback_text = ""
	        self.feedback_mood = ""
	        if update_display: self.show()
	        
	    def add_text(self, text: str, style: Text_Style):
	        print('add_text')
	        self.canvas.text(text, y= style.y, \
	                         font_size= style.font_size, color= style.color)
	        
	    def show(self):
	        print('showing screen')
	        self.canvas.clear()
	        
	        if self.answer_text:
	            self.add_text(self.answer_text, self.answer_style)
	        if self.input_text:
	            self.add_text(self.input_text, self.input_style)
	        
	        if self.feedback_text:
	            if self.feedback_mood == 'positive':
	                self.add_text(self.feedback_text,\
	                    self.feedback_style_positive)
	            elif self.feedback_mood == 'negative':
	                self.add_text(self.feedback_text,\
	                    self.feedback_style_negative)
	            elif self.feedback_mood == 'neutral':
	                self.add_text(self.feedback_text,\
	                    self.feedback_style_neutral)
	            else:
	                print('Display: error: unknown feedback mood {}'\
	                    .format(self.feedback_mood))
	                exit(-1)
	            
	        self.canvas.prepare()
	        self.canvas.show()
	__end__
	set _prepare ""

define inline_script Keyboard_Input
	set description "Executes Python code"
	___run__
	class Keyboard_Input:
	    def __init__(self, keyboard_setup: Keyboard_Setup, interface = None):
	        self.keyboard = Keyboard()
	        self.keyboard_setup = keyboard_setup
	        self.interface = interface
	        self.set_to_init_values()
	        
	    def set_to_init_values(self):
	        self.n_presses = 0
	        self.text = ""
	        self.t_first_input = 0
	        self.t_last_empty = 0
	        self.t_return = 0
	        self.has_been_erased_completely = False
	        
	    def set_interface(self, interface):
	        self.interface = interface
	        
	    def register_times(self, key):
	        t = clock.time()
	        if not self.n_presses and not self.is_ctrl_char(key):
	            self.t_first_input = t
	        if not self.text and not self.is_ctrl_char(key):
	            self.t_last_empty = t
	        if self.is_ctrl_char(key) and \
	            self.keyboard_setup.ctrl_char_mapping[key] == 'return':
	            self.t_return = t
	        
	    def add_char_to_end(self, char):
	        self.text += char
	        
	    def remove_char_from_end(self):
	        if self.text == '': return
	        if len(self.text) == 1: self.has_been_erased_completely = True
	        self.text = self.text[:-1]
	        
	    def is_ctrl_char(self, key: str):
	        return key in self.keyboard_setup.ctrl_char_mapping.keys()
	        
	    def parse_ctrl_char(self, key: str):
	        action = self.keyboard_setup.ctrl_char_mapping[key]
	        
	        if action == 'return':
	            self.is_done = True
	        elif action == 'remove_char_from_end':
	            self.remove_char_from_end()
	        elif action == 'repeat_cue':
	            self.interface.repeat_cue()
	        
	    def parse_char(self, key: str):
	        if key == 'space': self.add_char_to_end(' ')
	        else: self.add_char_to_end(self.keyboard.to_chr(key))
	    
	    def parse_key_press(self, key: str):
	        if self.is_ctrl_char(key): self.parse_ctrl_char(key)
	        else: self.parse_char(key)
	        
	    def take_input(self):
	        self.set_to_init_values()
	        self.is_done = False
	        while not self.is_done:
	            key, _ = self.keyboard.get_key()
	            print(key)
	            self.register_times(key)
	            self.parse_key_press(key)
	            self.interface.display.set_input_text(self.text)
	        return self.text, self.t_first_input, self.has_been_erased_completely
	__end__
	set _prepare ""

define inline_script Keyboard_Setup_Class
	set description "Executes Python code"
	___run__
	class Keyboard_Setup(NamedTuple):
	    ctrl_char_mapping: dict
	__end__
	set _prepare ""

define inline_script Load_Facts
	set description "Executes Python code"
	___run__
	import random
	
	facts_instruments = [Fact(1,"accordeon", "accordeon"),
			 Fact(2,"clarinet", "clarinet"),
		     Fact(3,"drums", "drums"),
			 Fact(4, "electric_guitar", "electric guitar"),
			 Fact(5, "flute", "flute"),
			 Fact(6, "frenchhorn","french horn"),
			 Fact(7, "harmonica", "harmonica"),
			 Fact(8, "harp", "harp"),
			Fact(9, "maraccas", "maraccas"),
			Fact(10, "piano", "piano")]
			
	random.shuffle(facts_instruments)
	
	facts = [Fact(1,"c3", "c"),
			 Fact(2, "e3", "e"),
			 Fact(3, "g3", "g"),
			 Fact(4, "b4", "b"),
			 Fact(5, "c4", "c")]
	
	random.shuffle(facts)
	
	# doing this by hand for now (only whole pitches)
	
	#interface = UI()
	#m = Experiment(interface, facts)
	#minstruments= Experiment(interface, factsinstrument)
	#mRelative = Experiment(interface, 'namedIntervals.csv')
	
	
	
	facts_relative = []
	
	with open(pool['namedIntervals.csv']) as f:
		lines = f.readlines()
		for i, line in enumerate(lines[1:]):
			cells = line.strip().split(',')
			facts_relative.append(Fact(i, int(cells[1]), str(cells[2]).lower()))
	
	random.shuffle(facts_relative)
	
	for fact in facts:
		m.add_fact(fact)
	for fact in facts_instruments:
		m_instruments.add_fact(fact)
	for fact in facts_relative:
		m_relative.add_fact(fact)
	__end__
	set _prepare ""

define inline_script Model_Package
	set description "Executes Python code"
	___run__
	class Model_Package():
	    def __init__(self, \
	                 spacing_model: SpacingModel, \
	                 facts: list, \
	                 condition_name: str, \
	                 cue_parse_function = None):
	        self.spacing_model = spacing_model
	        self.facts = facts
	        self.condition_name = condition_name
	        self.cue_parse_function = cue_parse_function
	__end__
	set _prepare ""

define loop Relative_pitch_loop_mask
	set source_file ""
	set source table
	set repeat 1
	set order random
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if never
	setcycle 0 empty_column ""
	run interval_w_mask_sequence

define loop Relative_pitch_loop_mask_1
	set source_file ""
	set source table
	set repeat 1
	set order random
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if never
	setcycle 0 empty_column ""
	run ""

define loop Relative_pitch_loop_no_mask_
	set source_file ""
	set source table
	set repeat 1
	set order random
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if never
	setcycle 0 empty_column ""
	run interval_wo_mask_sequence

define inline_script Run_Item
	set description "Executes Python code"
	___run__
	def run_item(fact, model_package, trial_start_time, \
	             is_masked, learning_or_test, show_answer):
	    cue = fact.question
	    
	    if model_package.cue_parse_function:
	        cue = model_package.cue_parse_function(cue)
	
	    answer = fact.answer
	    
	    results = ui.present_item(cue, answer, show_answer)
	    
	    rt = results['time'] - trial_start_time \
	    	if not results['response_has_been_erased'] \
	    		else float('inf')
	    		
	    correct = results['correct']
	    user_answer = results['response']
	    
	    response = Response(fact= fact, \
	                        start_time= trial_start_time, \
	                        rt= rt, \
	                        correct= correct, \
	                        condition= model_package.condition_name, \
	                        mask= is_masked, \
	                        test= learning_or_test, \
	                        user_answer= user_answer)
	    
	    model_package.spacing_model.register_response(response) 
	    
	    clock.sleep(var.feedback_duration)
	    
	    # Clear the screen between trials
	    ui.clear_screen()
	    
	    clock.sleep(var.inter_trial_interval)
	    
	    # Check if time is up
	    if clock.time() - var.session_start_time >= var.session_duration:
	    	var.time_up = True
	    	
	    # Increment trial number
	    var.trial_num += 1
	
	def run_learning_item(model_package, is_masked):
	    trial_start_time = clock.time()
	    learning_fact, is_new = \
		model_package.spacing_model.get_next_fact(current_time = \
								trial_start_time)
	    run_item(learning_fact, model_package, trial_start_time, \
	             is_masked, 'learning', is_new)
	
	
	def run_test_item(model_package, test_fact, is_masked):
	    trial_start_time = clock.time()
	    run_item(test_fact, model_package, trial_start_time, \
	             is_masked, 'test', False)
	    
	def run_masked_learning(mask_package, other_package):
	    end_time = clock.time() + var.session_duration
	    
	    while clock.time() < end_time:
	        run_learning_item(mask_package, True)
	        run_learning_item(other_package, True)
	        
	def run_unmasked_learning(other_package):
	    end_time = clock.time() + var.session_duration
	    
	    while clock.time() < end_time:
	        run_learning_item(other_package, False)
	        
	def run_masked_test(mask_package, other_package):
	    n_facts = min(len(mask_package.facts), len(other_package.facts))
	    
	    mask_facts = random.sample(mask_package.facts, n_facts)
	    other_facts = random.sample(other_package.facts, n_facts)
	    
	    for i in range(n_facts):
	        run_test_item(mask_package, mask_facts[i], True)
	        run_test_item(other_package, other_facts[i], True)
	        
	def run_unmasked_test(other_package):
	    n_facts = len(other_package.facts)
	    
	    other_facts = random.sample(other_package.facts, n_facts)
	    
	    for i in range(n_facts):
	        run_test_item(other_package, other_facts[i], False)
	__end__
	set _prepare ""

define inline_script Run_Trial_Item
	set description "Executes Python code"
	___run__
	def run_trial_item(spacing_model, condition, mask, test, \
	                   cue_parse_function= None):
	    trial_start_time = clock.time()
	    
	    next_fact, is_new = \
	    	spacing_model.get_next_fact(current_time = \
	    							trial_start_time)
	
	    cue = next_fact.question
	    
	    if cue_parse_function:
	        cue = cue_parse_function(cue)
	
	    answer = next_fact.answer
	    
	    results = ui.present_item(cue, answer, is_new)
	    
	    rt = results['time'] - trial_start_time \
	    	if not results['response_has_been_erased'] \
	    		else float('inf')
	    		
	    correct = results['correct']
	    user_answer = results['response']
	    
	    response = Response(fact= next_fact, \
	        start_time= trial_start_time, rt= rt, correct= correct, \
	        condition= condition, mask= mask, test= test,\
	        user_answer= user_answer)
	    
	    spacing_model.register_response(response) 
	    
	    clock.sleep(var.feedback_duration)
	    
	    # Clear the screen between trials
	    ui.clear_screen()
	    
	    clock.sleep(var.inter_trial_interval)
	    
	    # Check if time is up
	    if clock.time() - var.session_start_time >= var.session_duration:
	    	var.time_up = True
	    	
	    # Increment trial number
	    var.trial_num += 1
	    
	__end__
	set _prepare ""

define loop Single_notes_no_masking
	set source_file ""
	set source table
	set repeat 1
	set order sequential
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if never
	setcycle 0 empty_column ""
	run pitch_wo_mask_sequence

define loop TestingTrial
	set source_file ""
	set source table
	set repeat 1
	set order random
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if never
	setcycle 0 empty_column ""
	run Testingblock_mask

define sketchpad Testing_instructions_1
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Testing phase begins now<br />Press any key to continue<br /><br />" x=0 y=0 z_index=0

define sketchpad Testing_instructions_2
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Testing phase begins now<br />Press any key to continue<br /><br />" x=0 y=0 z_index=0

define sketchpad Testing_instructions_2_1
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Testing phase begins now<br />Press any key to continue<br /><br />" x=0 y=0 z_index=0

define sketchpad Testing_instructions_old
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Testing phase begins now<br />Press any key to continue<br /><br />" x=0 y=0 z_index=0

define inline_script TestingblockInstrument
	set description "Executes Python code"
	___run__
	#####
	
	
	for instrument in factsinstrument[4:5]:
		trial_start_time = clock.time()
		src = pool[instrument.question+".wav"]
		mysampler =Sampler(src,volume = 0.2)
		mysampler.play()
		mysampler.wait()
		
		#if newinst:
		#	my_canvas.text(answerinst, y = 50, font_size = 20)
		my_canvas.prepare()
		my_canvas.show()
		
		
		#here we need to add code to give possitive /or negative feedback for the instrument slimpstampen model
		
		
		# Listen for keyboard input and show keypresses on screen as they occur
		my_keyboard = Keyboard()
		keyboard_response = ""
		erased_answer = False
		rt = float("inf")
		
		# Keep listening for key presses until the user presses Enter
		while True:
			key, time = my_keyboard.get_key()
			
			# The first keypress determines the response time
			if keyboard_response == "" and not erased_answer:
				rt = clock.time() - trial_start_time
			
			if key == "return":
				break
				
			# press 1 for repeating the note
			if key == "1" or key =="backspace":
				if key == "1":
					Sampler(src).play()
				keyboard_response = keyboard_response[:-1]
				# If the answer is completely erased, the RT is no longer informative
				if keyboard_response == "":
					erased_answer = True
					rt = float("inf")
			
			elif key == "space":
				keyboard_response += " "
			
			else:
				keyboard_response += my_keyboard.to_chr(key)
		
			# Update what's on screen'
			my_canvas.clear()
			#my_canvas.text(prompt, font_size = 30)
			#if newinst:
			#	my_canvas.text(answerinst, y = 50, font_size = 20)
			my_canvas.text(keyboard_response, y = 100)
			my_canvas.prepare()
			my_canvas.show()
		
		
		# Check if the response is correct
		correct = keyboard_response == instrument.answer
		
		# Log response
		response = Response(instrument, trial_start_time, rt, correct)
		minstruments.register_response(response) 
		
		# Show feedback
		feedback_color = "green" if correct else "red"
		my_canvas.text(keyboard_response, y = 100, color = feedback_color)
		if not correct:
			my_canvas.text(instrument.answer, y = 150)
		my_canvas.prepare()
		my_canvas.show()
		clock.sleep(var.feedback_duration)
		
		# Clear the screen between trials
		my_canvas.clear()
		my_canvas.prepare()
		my_canvas.show()
		clock.sleep(var.inter_trial_interval)
		
		
		#var.time_up = False
		# reset the clock
		#var.session_start_time = clock.time()
	__end__
	set _prepare ""

define inline_script Testingblock_1
	set description "Executes Python code"
	___run__
	#####
	
	### combine the two lists of facts
	
	fact_list_to_test = []
	
	# extra randomizer
	random.shuffle(facts)
	i = 0
	while i < len(facts): #merging the two lists counterwise
	    fact_list_to_test.append((facts[i], "pitch"))
	    i += 1
	
	for fact in fact_list_to_test:    # should test all
	    test_fact, condition = fact
	    trial_start_time = clock.time()
	    src = pool[test_fact.question+".wav"]
	    volume_set = 0.2
	    if condition == "pitch":
	        volume_set = 1
	    mysampler = Sampler(src,volume = volume_set)
	    mysampler.play()
	    mysampler.wait()
	    
	    #if newinst:
	    #	my_canvas.text(answerinst, y = 50, font_size = 20)
	    my_canvas.prepare()
	    my_canvas.show()
	    
	    
	    #here we need to add code to give possitive /or negative feedback for the instrument slimpstampen model
	    
	    
	    # Listen for keyboard input and show keypresses on screen as they occur
	    my_keyboard = Keyboard()
	    keyboard_response = ""
	    erased_answer = False
	    rt = float("inf")
	    
	    # Keep listening for key presses until the user presses Enter
	    while True:
	    	key, time = my_keyboard.get_key()
	    	
	    	# The first keypress determines the response time
	    	if keyboard_response == "" and not erased_answer:
	    		rt = clock.time() - trial_start_time
	    	
	    	if key == "return":
	    		break
	    		
	    	# press 1 for repeating the note
	    	if key == "1" or key =="backspace":
	    		if key == "1":
	    			Sampler(src).play()
	    		keyboard_response = keyboard_response[:-1]
	    		# If the answer is completely erased, the RT is no longer informative
	    		if keyboard_response == "":
	    			erased_answer = True
	    			rt = float("inf")
	    	
	    	elif key == "space":
	    		keyboard_response += " "
	    	
	    	else:
	    		keyboard_response += my_keyboard.to_chr(key)
	    
	    	# Update what's on screen'
	    	my_canvas.clear()
	    	#my_canvas.text(prompt, font_size = 30)
	    	#if newinst:
	    	#	my_canvas.text(pitch.answer, y = 50, font_size = 20)
	    	my_canvas.text(keyboard_response, y = 100)
	    	my_canvas.prepare()
	    	my_canvas.show()
	    
	    
	    # Check if the response is correct
	    correct = keyboard_response == test_fact.answer
	    
	    # Log response
	    response = Response(test_fact, trial_start_time, rt, correct, condition, "no_mask", "test", keyboard_response)
	    m.register_response(response) 
	   
	    
	    # Show feedback
	    feedback_color = "green" if correct else "red"
	    my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	    if not correct:
	    	my_canvas.text(test_fact.answer, y = 150)
	    my_canvas.prepare()
	    my_canvas.show()
	    clock.sleep(var.feedback_duration)
	    
	    # Clear the screen between trials
	    my_canvas.clear()
	    my_canvas.prepare()
	    my_canvas.show()
	    clock.sleep(var.inter_trial_interval)
	    var.trial_num += 1
	    
	    
	    
	    var.time_up = False
	    
	    
	    
	__end__
	set _prepare ""

define inline_script Testingblock_2
	set description "Executes Python code"
	___run__
	#####
	
	### combine the two lists of facts
	
	def get_two_note_names(answer, second_note):
	    all_notes = ['a3', 'a-3', 'b3', 'c3', 'c-3', 'd3', 'd-3', 'e3', 'f3', 'f-3', 'g3', 'g-3',
	                 'a4', 'a-4', 'b4', 'c4', 'c-4', 'd4', 'd-4', 'e4', 'f4', 'f-4', 'g4', 'g-4',
	                 'a5', 'a-5', 'b5', 'c5', 'c-5', 'd5', 'd-5', 'e5', 'f5', 'f-5', 'g5', 'g-5']
	
	
	    first_list = ['a3', 'a-3', 'b3', 'c3', 'c-3', 'd3', 'd-3', 'e3', 'f3', 'f-3', 'g3', 'g-3',
	                     'a4', 'a-4', 'b4', 'c4', 'c-4', 'd4', 'd-4', 'e4', 'f4', 'f-4', 'g4', 'g-4']
	    asc = 1
	
	
	    first_note_instant = random.choice(first_list)
	
	    index_first_note = all_notes.index(first_note_instant)
	
	    if str("octave") in answer:
		    index_second_note = index_first_note + asc*12
	    else:
		    index_second_note = index_first_note + int(second_note)
	     
	
		
	    second_note_instant = all_notes[index_second_note]
	    return first_note_instant, second_note_instant
	
	
	    
	
	fact_list_to_test = []
	
	# extra randomizer
	random.shuffle(facts_relative)
	random.shuffle(facts_instruments)
	i = 0
	while i < len(facts_relative) and i < len(facts_instruments): #merging the two lists counterwise
	    fact_list_to_test.append((facts_instruments[i], "instrument"))
	    fact_list_to_test.append((facts_relative[i], "relative"))
	    i += 1
	
	
	
	for fact in fact_list_to_test:    # NOW TESTS TWO FACTS
	    test_fact, condition = fact
	    trial_start_time = clock.time()
	    
	    volume_set = 0.2
	    if condition == "relative":
	        volume_set = 1
	        note1, note2 = get_two_note_names(test_fact.answer, test_fact.question)
	        src = pool[note1+'.wav']
	        Sampler(src).play()
	
	        clock.sleep(1000)
	
	        src = pool[note2+'.wav']
	        Sampler(src).play()
	
	        
	    else:
	        src = pool[test_fact.question+".wav"]
	        mysampler = Sampler(src,volume = volume_set)
	        mysampler.play()
	        mysampler.wait()
	    
	    #if newinst:
	    #	my_canvas.text(answerinst, y = 50, font_size = 20)
	    my_canvas.prepare()
	    my_canvas.show()
	    
	    
	    #here we need to add code to give possitive /or negative feedback for the instrument slimpstampen model
	    
	    
	    # Listen for keyboard input and show keypresses on screen as they occur
	    my_keyboard = Keyboard()
	    keyboard_response = ""
	    erased_answer = False
	    rt = float("inf")
	    
	    # Keep listening for key presses until the user presses Enter
	    while True:
	    	key, time = my_keyboard.get_key()
	    	
	    	# The first keypress determines the response time
	    	if keyboard_response == "" and not erased_answer:
	    		rt = clock.time() - trial_start_time
	    	
	    	if key == "return":
	    		break
	    		
	    	# press 1 for repeating the note
	    	if key == "1" or key =="backspace":
	            if key == "1":
	                if condition == "instrument":
	                    Sampler(src).play()
	                else:
	                    src = pool[note1+'.wav']
	                    Sampler(src).play()
	
	                    clock.sleep(1000)
	
	                    src = pool[note2+'.wav']
	                    Sampler(src).play()
	
	            keyboard_response = keyboard_response[:-1]
	    		# If the answer is completely erased, the RT is no longer informative
	            if keyboard_response == "":
	                erased_answer = True
	                rt = float("inf")
	    	
	    	elif key == "space":
	    		keyboard_response += " "
	    	
	    	else:
	    		keyboard_response += my_keyboard.to_chr(key)
	    
	    	# Update what's on screen'
	    	my_canvas.clear()
	    	#my_canvas.text(prompt, font_size = 30)
	    	#if newinst:
	    	#	my_canvas.text(pitch.answer, y = 50, font_size = 20)
	    	my_canvas.text(keyboard_response, y = 100)
	    	my_canvas.prepare()
	    	my_canvas.show()
	    
	    
	    # Check if the response is correct
	    
	    regex = re.compile('[^a-z]')
	    print(regex.sub('', keyboard_response), regex.sub('', answer))
	    correct = regex.sub('', keyboard_response) == regex.sub('', test_fact.answer)
	    
	    # Log response
	    response = Response(test_fact, trial_start_time, rt, correct, condition, "mask", "test", regex.sub('', keyboard_response))
	    if condition == "relative":
	        m_relative.register_response(response) 
	    elif condition == "instrument":
	        m_instruments.register_response(response) 
	    
	    # Show feedback
	    feedback_color = "green" if correct else "red"
	    my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	    if not correct:
	    	my_canvas.text(test_fact.answer, y = 150)
	    my_canvas.prepare()
	    my_canvas.show()
	    clock.sleep(var.feedback_duration)
	    
	    # Clear the screen between trials
	    my_canvas.clear()
	    my_canvas.prepare()
	    my_canvas.show()
	    clock.sleep(var.inter_trial_interval)
	    var.trial_num += 1
	    
	    
	    
	    var.time_up = False
	    
	    
	    
	__end__
	set _prepare ""

define inline_script Testingblock_2_1
	set description "Executes Python code"
	___run__
	#####
	
	### combine the two lists of facts
	
	def get_two_note_names(answer, second_note):
	    
	    all_notes = ['a3', 'a-3', 'b3', 'c3', 'c-3', 'd3', 'd-3', 'e3', 'f3', 'f-3', 'g3', 'g-3',
	                 'a4', 'a-4', 'b4', 'c4', 'c-4', 'd4', 'd-4', 'e4', 'f4', 'f-4', 'g4', 'g-4',
	                 'a5', 'a-5', 'b5', 'c5', 'c-5', 'd5', 'd-5', 'e5', 'f5', 'f-5', 'g5', 'g-5']
	
	    first_list = ['a3', 'a-3', 'b3', 'c3', 'c-3', 'd3', 'd-3', 'e3', 'f3', 'f-3', 'g3', 'g-3',
	                 'a4', 'a-4', 'b4', 'c4', 'c-4', 'd4', 'd-4', 'e4', 'f4', 'f-4', 'g4', 'g-4']
	    asc = 1
	
	
	    first_note_instant = random.choice(first_list)
	
	    index_first_note = all_notes.index(first_note_instant)
	
	    if str("octave") in answer:
		    index_second_note = index_first_note + asc*12
	    else:
		    index_second_note = index_first_note + int(second_note)
	    
	    print(first_note_instant)
	    print(index_first_note, index_second_note)
		
	    second_note_instant = all_notes[index_second_note]
	    return first_note_instant, second_note_instant
	
	
	    
	
	fact_list_to_test = []
	
	# extra randomizer
	random.shuffle(facts_relative)
	i = 0
	while i < len(facts_relative): #merging the two lists counterwise
	    fact_list_to_test.append((facts_relative[i], "relative"))
	    i += 1
	
	
	for fact in fact_list_to_test:    # NOW TESTS TWO FACTS
	    test_fact, condition = fact
	    trial_start_time = clock.time()
	    
	    volume_set = 0.2
	    if condition == "relative":
	        volume_set = 1
	        note1, note2 = get_two_note_names(test_fact.answer, test_fact.question)
	        src = pool[note1+'.wav']
	        Sampler(src).play()
	
	        clock.sleep(1000)
	
	        src = pool[note2+'.wav']
	        Sampler(src).play()
	
	        
	    else:
	        src = pool[test_fact.question+".wav"]
	        mysampler = Sampler(src,volume = volume_set)
	        mysampler.play()
	        mysampler.wait()
	    
	    #if newinst:
	    #	my_canvas.text(answerinst, y = 50, font_size = 20)
	    
	  
	    #my_canvas.text(note1, y = 10)
	    #my_canvas.text(note2, y = 20)
	    
	    my_canvas.prepare()
	    my_canvas.show()
	    
	    
	    #here we need to add code to give possitive /or negative feedback for the instrument slimpstampen model
	    
	    
	    # Listen for keyboard input and show keypresses on screen as they occur
	    my_keyboard = Keyboard()
	    keyboard_response = ""
	    erased_answer = False
	    rt = float("inf")
	    
	    
	
	    
	    # Keep listening for key presses until the user presses Enter
	    while True:
	    	key, time = my_keyboard.get_key()
	    	
	    	# The first keypress determines the response time
	    	if keyboard_response == "" and not erased_answer:
	    		rt = clock.time() - trial_start_time
	    	
	    	if key == "return":
	    		break
	    		
	    	# press 1 for repeating the note
	    	if key == "1" or key =="backspace":
	            if key == "1":
	                if condition == "instrument":
	                    Sampler(src).play()
	                else:
	                    src = pool[note1+'.wav']
	                    Sampler(src).play()
	
	                    clock.sleep(1000)
	
	                    src = pool[note2+'.wav']
	                    Sampler(src).play()
	
	            keyboard_response = keyboard_response[:-1]
	    		# If the answer is completely erased, the RT is no longer informative
	            if keyboard_response == "":
	                erased_answer = True
	                rt = float("inf")
	    	
	    	elif key == "space":
	    		keyboard_response += " "
	    	
	    	else:
	    		keyboard_response += my_keyboard.to_chr(key)
	    
	    	# Update what's on screen'
	    	my_canvas.clear()
	    	#my_canvas.text(prompt, font_size = 30)
	    	#if newinst:
	    	#	my_canvas.text(pitch.answer, y = 50, font_size = 20)
	    	my_canvas.text(keyboard_response, y = 100)
	    	my_canvas.prepare()
	    	my_canvas.show()
	    
	    
	    # Check if the response is correct
	    
	    regex = re.compile('[^a-z]')
	    print(regex.sub('', keyboard_response), regex.sub('', test_fact.answer))
	    correct = regex.sub('', keyboard_response) == regex.sub('', test_fact.answer)
	    
	    # Log response
	    response = Response(test_fact, trial_start_time, rt, correct, condition,"no_mask", "test", regex.sub('', keyboard_response))
	    if condition == "relative":
	        m_relative.register_response(response) 
	    
	    # Show feedback
	    feedback_color = "green" if correct else "red"
	    my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	    if not correct:
	    	my_canvas.text(test_fact.answer, y = 150)
	    my_canvas.prepare()
	    my_canvas.show()
	    clock.sleep(var.feedback_duration)
	    
	    # Clear the screen between trials
	    my_canvas.clear()
	    my_canvas.prepare()
	    my_canvas.show()
	    clock.sleep(var.inter_trial_interval)
	    var.trial_num += 1
	    
	    
	    
	    var.time_up = False
	    
	    
	    
	__end__
	set _prepare ""

define inline_script Testingblock_2_2
	set description "Executes Python code"
	___run__
	#####
	
	### combine the two lists of facts
	
	def get_two_note_names(answer, second_note):
	    all_notes = ['a3', 'a-3', 'b3', 'c3', 'c-3', 'd3', 'd-3', 'e3', 'f3', 'f-3', 'g3', 'g-3',
	                 'a4', 'a-4', 'b4', 'c4', 'c-4', 'd4', 'd-4', 'e4', 'f4', 'f-4', 'g4', 'g-4',
	                 'a5', 'a-5', 'b5', 'c5', 'c-5', 'd5', 'd-5', 'e5', 'f5', 'f-5', 'g5', 'g-5']
	
	
	    first_list = ['a3', 'a-3', 'b3', 'c3', 'c-3', 'd3', 'd-3', 'e3', 'f3', 'f-3', 'g3', 'g-3',
	                     'a4', 'a-4', 'b4', 'c4', 'c-4', 'd4', 'd-4', 'e4', 'f4', 'f-4', 'g4', 'g-4']
	    asc = 1
	
	
	    first_note_instant = random.choice(first_list)
	
	    index_first_note = all_notes.index(first_note_instant)
	
	    if str("octave") in answer:
		    index_second_note = index_first_note + asc*12
	    else:
		    index_second_note = index_first_note + int(second_note)
	     
	
		
	    second_note_instant = all_notes[index_second_note]
	    return first_note_instant, second_note_instant
	
	
	    
	
	fact_list_to_test = []
	
	# extra randomizer
	random.shuffle(facts_relative)
	random.shuffle(facts_instruments)
	i = 0
	while i < len(facts_relative) and i < len(facts_instruments): #merging the two lists counterwise
	    fact_list_to_test.append((facts_instruments[i], "instrument"))
	    fact_list_to_test.append((facts_relative[i], "relative"))
	    i += 1
	
	
	
	for fact in fact_list_to_test:    # NOW TESTS TWO FACTS
	    test_fact, condition = fact
	    trial_start_time = clock.time()
	    
	    volume_set = 0.2
	    if condition == "relative":
	        volume_set = 1
	        note1, note2 = get_two_note_names(test_fact.answer, test_fact.question)
	        src = pool[note1+'.wav']
	        Sampler(src).play()
	
	        clock.sleep(1000)
	
	        src = pool[note2+'.wav']
	        Sampler(src).play()
	
	        
	    else:
	        src = pool[test_fact.question+".wav"]
	        mysampler = Sampler(src,volume = volume_set)
	        mysampler.play()
	        mysampler.wait()
	    
	    #if newinst:
	    #	my_canvas.text(answerinst, y = 50, font_size = 20)
	    my_canvas.prepare()
	    my_canvas.show()
	    
	    
	    #here we need to add code to give possitive /or negative feedback for the instrument slimpstampen model
	    
	    
	    # Listen for keyboard input and show keypresses on screen as they occur
	    my_keyboard = Keyboard()
	    keyboard_response = ""
	    erased_answer = False
	    rt = float("inf")
	    
	    # Keep listening for key presses until the user presses Enter
	    while True:
	    	key, time = my_keyboard.get_key()
	    	
	    	# The first keypress determines the response time
	    	if keyboard_response == "" and not erased_answer:
	    		rt = clock.time() - trial_start_time
	    	
	    	if key == "return":
	    		break
	    		
	    	# press 1 for repeating the note
	    	if key == "1" or key =="backspace":
	            if key == "1":
	                if condition == "instrument":
	                    Sampler(src).play()
	                else:
	                    src = pool[note1+'.wav']
	                    Sampler(src).play()
	
	                    clock.sleep(1000)
	
	                    src = pool[note2+'.wav']
	                    Sampler(src).play()
	
	            keyboard_response = keyboard_response[:-1]
	    		# If the answer is completely erased, the RT is no longer informative
	            if keyboard_response == "":
	                erased_answer = True
	                rt = float("inf")
	    	
	    	elif key == "space":
	    		keyboard_response += " "
	    	
	    	else:
	    		keyboard_response += my_keyboard.to_chr(key)
	    
	    	# Update what's on screen'
	    	my_canvas.clear()
	    	#my_canvas.text(prompt, font_size = 30)
	    	#if newinst:
	    	#	my_canvas.text(pitch.answer, y = 50, font_size = 20)
	    	my_canvas.text(keyboard_response, y = 100)
	    	my_canvas.prepare()
	    	my_canvas.show()
	    
	    
	    # Check if the response is correct
	    
	    regex = re.compile('[^a-z]')
	    print(regex.sub('', keyboard_response), regex.sub('', answer))
	    correct = regex.sub('', keyboard_response) == regex.sub('', test_fact.answer)
	    
	    # Log response
	    response = Response(test_fact, trial_start_time, rt, correct, condition, "mask", "test", regex.sub('', keyboard_response))
	    if condition == "relative":
	        m_relative.register_response(response) 
	    elif condition == "instrument":
	        m_instruments.register_response(response) 
	    
	    # Show feedback
	    feedback_color = "green" if correct else "red"
	    my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	    if not correct:
	    	my_canvas.text(test_fact.answer, y = 150)
	    my_canvas.prepare()
	    my_canvas.show()
	    clock.sleep(var.feedback_duration)
	    
	    # Clear the screen between trials
	    my_canvas.clear()
	    my_canvas.prepare()
	    my_canvas.show()
	    clock.sleep(var.inter_trial_interval)
	    var.trial_num += 1
	    
	    
	    
	    var.time_up = False
	    
	    
	    
	__end__
	set _prepare ""

define inline_script Testingblock_mask
	set description "Executes Python code"
	___run__
	#####
	
	### combine the two lists of facts
	
	fact_list_to_test = []
	
	# extra randomizer
	random.shuffle(facts)
	random.shuffle(facts_instruments)
	i = 0
	while i < len(facts) and i < len(facts_instruments): #merging the two lists counterwise
	    fact_list_to_test.append((facts_instruments[i], "instrument"))
	    fact_list_to_test.append((facts[i], "pitch"))
	    i += 1
	
	
	
	
	for fact in fact_list_to_test:    # should test all
	    test_fact, condition = fact
	    trial_start_time = clock.time()
	    src = pool[test_fact.question+".wav"]
	    volume_set = 0.2
	    if condition == "pitch":
	        volume_set = 1
	    mysampler = Sampler(src,volume = volume_set)
	    mysampler.play()
	    mysampler.wait()
	    
	    #if newinst:
	    #	my_canvas.text(answerinst, y = 50, font_size = 20)
	    my_canvas.prepare()
	    my_canvas.show()
	    
	    
	    #here we need to add code to give possitive /or negative feedback for the instrument slimpstampen model
	    
	    
	    # Listen for keyboard input and show keypresses on screen as they occur
	    my_keyboard = Keyboard()
	    keyboard_response = ""
	    erased_answer = False
	    rt = float("inf")
	    
	    # Keep listening for key presses until the user presses Enter
	    while True:
	    	key, time = my_keyboard.get_key()
	    	
	    	# The first keypress determines the response time
	    	if keyboard_response == "" and not erased_answer:
	    		rt = clock.time() - trial_start_time
	    	
	    	if key == "return":
	    		break
	    		
	    	# press 1 for repeating the note
	    	if key == "1" or key =="backspace":
	    		if key == "1":
	    			Sampler(src).play()
	    		keyboard_response = keyboard_response[:-1]
	    		# If the answer is completely erased, the RT is no longer informative
	    		if keyboard_response == "":
	    			erased_answer = True
	    			rt = float("inf")
	    	
	    	elif key == "space":
	    		keyboard_response += " "
	    	
	    	else:
	    		keyboard_response += my_keyboard.to_chr(key)
	    
	    	# Update what's on screen'
	    	my_canvas.clear()
	    	#my_canvas.text(prompt, font_size = 30)
	    	#if newinst:
	    	#	my_canvas.text(pitch.answer, y = 50, font_size = 20)
	    	my_canvas.text(keyboard_response, y = 100)
	    	my_canvas.prepare()
	    	my_canvas.show()
	    
	    
	    # Check if the response is correct
	    correct = keyboard_response == test_fact.answer
	    
	    # Log response
	    response = Response(test_fact, trial_start_time, rt, correct, condition, "mask", "test", keyboard_response)
	    if condition == "pitch":
	        m.register_response(response) 
	    elif condition == "instrument":
	        m_instruments.register_response(response) 
	    
	    # Show feedback
	    feedback_color = "green" if correct else "red"
	    my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	    if not correct:
	    	my_canvas.text(test_fact.answer, y = 150)
	    my_canvas.prepare()
	    my_canvas.show()
	    clock.sleep(var.feedback_duration)
	    
	    # Clear the screen between trials
	    my_canvas.clear()
	    my_canvas.prepare()
	    my_canvas.show()
	    clock.sleep(var.inter_trial_interval)
	    var.trial_num += 1
	    
	    
	    
	    var.time_up = False
	    
	    
	    
	__end__
	set _prepare ""

define inline_script Text_Style
	set description "Executes Python code"
	___run__
	from typing import NamedTuple
	
	class Text_Style(NamedTuple):
	    y: int
	    font_size: int
	    color: str
	__end__
	set _prepare ""

define sketchpad Training_instructions_1
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color="#fec52d" font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Starting training block... <br />press any key to continue, when you're ready" x=-96 y=-32 z_index=0

define sketchpad Training_instructions_2
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color="#fec52d" font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Starting training block... <br />press any key to continue, when you're ready" x=-96 y=-32 z_index=0

define sketchpad Training_instructions_2_1
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color="#fec52d" font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Starting training block... <br />press any key to continue, when you're ready" x=-96 y=-32 z_index=0

define sketchpad Training_instructions_old
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color="#fec52d" font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Starting training block... <br />press any key to continue, when you're ready" x=0.0 y=0.0 z_index=0

define sequence UI
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run ClassDefinitions always
	run UsefulFunctions always
	run UI_Setup always

define inline_script UI_Class
	set description "Executes Python code"
	___run__
	class UI:
	    class Item_State():
	        cue: str = ''
	        answer: str = ''
	        response: str = ''
	        response_has_been_erased: bool = False
	        time: float = float('inf')
	        correct: bool = False
	        
	        def as_dict(self):
	            return {'cue': self.cue,
	                    'answer': self.answer,
	                    'response': self.response,
	                    'response_has_been_erased': self.response_has_been_erased,
	                    'time': self.time,
	                    'correct': self.correct
	            }
	        
	    def __init__(self, display: Display = None, audio: Audio = None,
	                 keyboard: Keyboard_Input = None):
	        self.display: Display = display if display else Display()
	        self.audio: Audio = audio if audio else Audio()
	        self.keyboard: Keyboard_Input = keyboard \
	            if keyboard else Keyboard_Input()
	        self.keyboard.set_interface(self)
	        
	        self.set_to_init_values()
	    
	    def set_to_init_values(self):
	        self.item_state = UI.Item_State()
	        
	    def clear_screen(self):
	        self.display.clear()
	
	    def present_cue(self):
	        self.audio.play_audio(self.state.cue)
	        
	    def show_answer(self):
	        self.display.set_answer_text(self.state.answer)
	        
	    def repeat_cue(self):
	        self.present_cue()
	    
	    def check_response(self):
	        self.state.correct = \
	            (self.state.response == self.state.answer)
	        
	    def take_input(self):
	        self.state.response, self.state.time, \
	            self.state.response_has_been_erased = \
	                self.keyboard.take_input()
	    
	    def present_feedback(self):
	        if self.state.correct:
	            feedback_text = 'correct'
	            feedback_mood = 'positive'
	        else:
	            feedback_text = self.state.answer
	            feedback_mood = 'negative'
	            
	        self.display.set_feedback_text(feedback_text, feedback_mood)
	        
	    def set_cue_answer(self, cue, answer):
	        self.state = UI.Item_State()
	        self.state.cue = cue
	        self.state.answer = answer
	        
	    def present_item(self, cue, answer, show_answer: bool = False):
	        self.set_cue_answer(cue, answer)
	        self.clear_screen()
	        if show_answer: self.show_answer()
	        self.present_cue()
	        self.take_input()
	        self.audio.stop_audio()
	        self.check_response()
	        self.present_feedback()
	        return self.state.as_dict()
	        
	__end__
	set _prepare ""

define inline_script UI_Setup
	set description "Executes Python code"
	___run__
	ks = Keyboard_Setup({'return': 'return',\
	                     'backspace': 'remove_char_from_end',\
	                     '1': 'repeat_cue'})
	ki = Keyboard_Input(ks)
	ui = UI(keyboard = ki)
	__end__
	set _prepare ""

define sequence UsefulFunctions
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run Cue_Parse_Function_Relative_Pitch always
	run Run_Item always

define sketchpad change_group_to_interval_no_mask
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Now changing to intervals no masking" x=0 y=0 z_index=0

define sketchpad change_group_to_pitch_no_mask
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Going into Single note no masking" x=0 y=0 z_index=0

define sketchpad changegroup
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Going into Single note no masking" x=0 y=0 z_index=0

define sequence experiment
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run slimstampen_setup always
	run UI always
	run Load_Facts always
	run Create_Model_Packages always
	run instructions always
	run learning_session_setup always
	run pitch_w_mask_sequence always
	run pitch_wo_mask_sequence_1 always
	run switching_to_intervals always
	run interval_w_mask_sequence_1 always
	run interval_wo_mask_sequence_1 always
	run save_data always

define sketchpad instructions
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Instructions go here. Press any key to begin." x=0 y=-32 z_index=0
	draw textline center=1 color="#fd8008" font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Press 1 to repeat the fact" x=0 y=0 z_index=0

define loop instruments_while_items_left
	set source_file ""
	set source table
	set repeat 1
	set order random
	set description "Repeatedly runs another item"
	set cycles 3
	set continuous no
	set break_if_on_first yes
	set break_if never
	setcycle 0 instrument piano
	setcycle 1 instrument drums
	setcycle 2 instrument harp
	run ""

define inline_script interval_w_mask_learning_script
	set description "Executes Python code"
	set _run "run_masked_learning(instrument_package, interval_package)"
	set _prepare ""

define inline_script interval_w_mask_learning_script_1
	set description "Executes Python code"
	set _run "run_unmasked_learning(interval_package)"
	set _prepare ""

define inline_script interval_w_mask_script
	set description "Executes Python code"
	___run__
	run_learning_item(instrument_package, True)
	run_learning_item(interval_package, True)
	__end__
	set _prepare ""

define sequence interval_w_mask_sequence
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run Training_instructions_2 always
	run while_there_is_time_left_2 always
	run Testing_instructions_2 always
	run Testingblock_2 always

define sequence interval_w_mask_sequence_1
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run training_instructions always
	run interval_w_mask_learning_script always
	run testing_instructions always
	run interval_w_mask_test_script always

define inline_script interval_w_mask_test_script
	set description "Executes Python code"
	set _run "run_masked_test(instrument_package, interval_package)"
	set _prepare ""

define inline_script interval_w_mask_test_script_1
	set description "Executes Python code"
	set _run "run_unmasked_test(interval_package)"
	set _prepare ""

define sequence interval_wo_mask_sequence
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run Training_instructions_2_1 always
	run while_there_is_time_left_2_1 always
	run Testing_instructions_2_1 always
	run Testingblock_2_1 always

define sequence interval_wo_mask_sequence_1
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run change_group_to_interval_no_mask always
	run training_instructions always
	run interval_w_mask_learning_script_1 always
	run testing_instructions always
	run interval_w_mask_test_script_1 always

define sketchpad intervals
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Now starting Interval conditions" x=0 y=0 z_index=0

define sketchpad intervals_1
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Now starting Interval conditions" x=0 y=0 z_index=0

define inline_script learning_session_setup
	set description "Executes Python code"
	___run__
	# Start the clock
	var.session_start_time = clock.time()
	
	# Session will run until time_up == True
	var.time_up = False
	
	# Keep track of trial number
	var.trial_num = 1
	
	# Settings
	var.session_duration = 5000
	var.feedback_duration = 800
	var.inter_trial_interval = 200
	
	## testing phase
	var.end = False
	__end__
	set _prepare ""

define inline_script masking_script
	set description "Executes Python code"
	___run__
	trial_start_time = clock.time()
	
	# Get next fact from the model
	# next_factinst, newinst = m_instruments.get_next_fact(current_time = trial_start_time)
	# promptinst = next_factinst.question
	# answerinst = next_factinst.answer
	
	#next instrument
	next_factinst, newinst = m_instruments.get_next_fact(current_time = trial_start_time)
	promptinst = next_factinst.question
	answerinst = next_factinst.answer
	
	
	# Show prompt
	my_canvas = Canvas()
	
	
	src = pool[promptinst+".wav"]
	mysampler =Sampler(src,volume = 0.2)
	mysampler.play()
	#mysampler.wait()
	
	if newinst:
		my_canvas.text(answerinst, y = 50, font_size = 20)
	my_canvas.prepare()
	my_canvas.show()
	
	
	#here we need to add code to give possitive /or negative feedback for the instrument slimpstampen model
	
	
	# Listen for keyboard input and show keypresses on screen as they occur
	my_keyboard = Keyboard()
	keyboard_response = ""
	erased_answer = False
	rt = float("inf")
	
	# Keep listening for key presses until the user presses Enter
	while True:
		key, time = my_keyboard.get_key()
		
		# The first keypress determines the response time
		if keyboard_response == "" and not erased_answer:
			rt = clock.time() - trial_start_time
		
		if key == "return":
			break
			
		# press 1 for repeating the note
		if key == "1" or key =="backspace":
			if key == "1":
				Sampler(src).play()
			keyboard_response = keyboard_response[:-1]
			# If the answer is completely erased, the RT is no longer informative
			if keyboard_response == "":
				erased_answer = True
				rt = float("inf")
		
		elif key == "space":
			keyboard_response += " "
		
		else:
			keyboard_response += my_keyboard.to_chr(key)
	
		# Update what's on screen'
		my_canvas.clear()
		#my_canvas.text(prompt, font_size = 30)
		if newinst:
			my_canvas.text(answerinst, y = 50, font_size = 20)
		my_canvas.text(keyboard_response, y = 100)
		my_canvas.prepare()
		my_canvas.show()
	
	
	# Check if the response is correct
	correct = keyboard_response == answerinst
	
	# Log response
	response = Response(next_factinst, trial_start_time, rt, correct, "instrument", "mask", "train", keyboard_response)
	m_instruments.register_response(response) 
	
	# Show feedback
	feedback_color = "green" if correct else "red"
	my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	if not correct:
		my_canvas.text(answerinst, y = 150)
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.feedback_duration)
	
	# Clear the screen between trials
	my_canvas.clear()
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.inter_trial_interval)
	
	# Check if time is up
	if clock.time() - var.session_start_time >= var.session_duration:
		var.time_up = True
		
	# Increment trial number
	var.trial_num += 1
	__end__
	set _prepare ""

define inline_script masking_script_1
	set description "Executes Python code"
	___run__
	trial_start_time = clock.time()
	
	# Get next fact from the model
	# next_factinst, newinst = m_instruments.get_next_fact(current_time = trial_start_time)
	# promptinst = next_factinst.question
	# answerinst = next_factinst.answer
	
	#next instrument
	next_factinst, newinst = m_instruments.get_next_fact(current_time = trial_start_time)
	promptinst = next_factinst.question
	answerinst = next_factinst.answer
	
	
	# Show prompt
	my_canvas = Canvas()
	
	
	src = pool[promptinst+".wav"]
	mysampler =Sampler(src,volume = 0.2)
	mysampler.play()
	#mysampler.wait()
	
	if newinst:
		my_canvas.text(answerinst, y = 50, font_size = 20)
	my_canvas.prepare()
	my_canvas.show()
	
	
	#here we need to add code to give possitive /or negative feedback for the instrument slimpstampen model
	
	
	# Listen for keyboard input and show keypresses on screen as they occur
	my_keyboard = Keyboard()
	keyboard_response = ""
	erased_answer = False
	rt = float("inf")
	
	# Keep listening for key presses until the user presses Enter
	while True:
		key, time = my_keyboard.get_key()
		
		# The first keypress determines the response time
		if keyboard_response == "" and not erased_answer:
			rt = clock.time() - trial_start_time
		
		if key == "return":
			break
			
		# press 1 for repeating the note
		if key == "1" or key =="backspace":
			if key == "1":
				Sampler(src).play()
			keyboard_response = keyboard_response[:-1]
			# If the answer is completely erased, the RT is no longer informative
			if keyboard_response == "":
				erased_answer = True
				rt = float("inf")
		
		elif key == "space":
			keyboard_response += " "
		
		else:
			keyboard_response += my_keyboard.to_chr(key)
	
		# Update what's on screen'
		my_canvas.clear()
		#my_canvas.text(prompt, font_size = 30)
		if newinst:
			my_canvas.text(answerinst, y = 50, font_size = 20)
		my_canvas.text(keyboard_response, y = 100)
		my_canvas.prepare()
		my_canvas.show()
	
	
	# Check if the response is correct
	correct = keyboard_response == answerinst
	
	# Log response
	response = Response(next_factinst, trial_start_time, rt, correct, "instrument", "mask", "train", keyboard_response)
	m_instruments.register_response(response) 
	
	# Show feedback
	feedback_color = "green" if correct else "red"
	my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	if not correct:
		my_canvas.text(answerinst, y = 150)
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.feedback_duration)
	
	# Clear the screen between trials
	my_canvas.clear()
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.inter_trial_interval)
	
	# Check if time is up
	if clock.time() - var.session_start_time >= var.session_duration:
		var.time_up = True
		
	# Increment trial number
	var.trial_num += 1
	__end__
	set _prepare ""

define inline_script masking_script_1_1
	set description "Executes Python code"
	___run__
	trial_start_time = clock.time()
	
	# Get next fact from the model
	# next_factinst, newinst = minstruments.get_next_fact(current_time = trial_start_time)
	# promptinst = next_factinst.question
	# answerinst = next_factinst.answer
	
	#next instrument
	next_factinst, newinst = minstruments.get_next_fact(current_time = trial_start_time)
	promptinst = next_factinst.question
	answerinst = next_factinst.answer
	
	
	# Show prompt
	my_canvas = Canvas()
	
	
	src = pool[promptinst+".wav"]
	mysampler =Sampler(src,volume = 0.2)
	mysampler.play()
	#mysampler.wait()
	
	if newinst:
		my_canvas.text(answerinst, y = 50, font_size = 20)
	my_canvas.prepare()
	my_canvas.show()
	
	
	#here we need to add code to give possitive /or negative feedback for the instrument slimpstampen model
	
	
	# Listen for keyboard input and show keypresses on screen as they occur
	my_keyboard = Keyboard()
	keyboard_response = ""
	erased_answer = False
	rt = float("inf")
	
	# Keep listening for key presses until the user presses Enter
	while True:
		key, time = my_keyboard.get_key()
		
		# The first keypress determines the response time
		if keyboard_response == "" and not erased_answer:
			rt = clock.time() - trial_start_time
		
		if key == "return":
			break
			
		# press 1 for repeating the note
		if key == "1" or key =="backspace":
			if key == "1":
				Sampler(src).play()
			keyboard_response = keyboard_response[:-1]
			# If the answer is completely erased, the RT is no longer informative
			if keyboard_response == "":
				erased_answer = True
				rt = float("inf")
		
		elif key == "space":
			keyboard_response += " "
		
		else:
			keyboard_response += my_keyboard.to_chr(key)
	
		# Update what's on screen'
		my_canvas.clear()
		#my_canvas.text(prompt, font_size = 30)
		if newinst:
			my_canvas.text(answerinst, y = 50, font_size = 20)
		my_canvas.text(keyboard_response, y = 100)
		my_canvas.prepare()
		my_canvas.show()
	
	
	# Check if the response is correct
	correct = keyboard_response == answerinst
	
	# Log response
	response = Response(next_factinst, trial_start_time, rt, correct, "instrument", "train")
	minstruments.register_response(response) 
	
	# Show feedback
	feedback_color = "green" if correct else "red"
	my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	if not correct:
		my_canvas.text(answerinst, y = 150)
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.feedback_duration)
	
	# Clear the screen between trials
	my_canvas.clear()
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.inter_trial_interval)
	
	# Check if time is up
	if clock.time() - var.session_start_time >= var.session_duration:
		var.time_up = True
		
	# Increment trial number
	var.trial_num += 1
	__end__
	set _prepare ""

define inline_script masking_script_1_2
	set description "Executes Python code"
	___run__
	trial_start_time = clock.time()
	
	# Get next fact from the model
	# next_factinst, newinst = m_instruments.get_next_fact(current_time = trial_start_time)
	# promptinst = next_factinst.question
	# answerinst = next_factinst.answer
	
	#next instrument
	next_factinst, newinst = m_instruments.get_next_fact(current_time = trial_start_time)
	promptinst = next_factinst.question
	answerinst = next_factinst.answer
	
	
	# Show prompt
	my_canvas = Canvas()
	
	
	src = pool[promptinst+".wav"]
	mysampler =Sampler(src,volume = 0.2)
	mysampler.play()
	#mysampler.wait()
	
	if newinst:
		my_canvas.text(answerinst, y = 50, font_size = 20)
	my_canvas.prepare()
	my_canvas.show()
	
	
	#here we need to add code to give possitive /or negative feedback for the instrument slimpstampen model
	
	
	# Listen for keyboard input and show keypresses on screen as they occur
	my_keyboard = Keyboard()
	keyboard_response = ""
	erased_answer = False
	rt = float("inf")
	
	# Keep listening for key presses until the user presses Enter
	while True:
		key, time = my_keyboard.get_key()
		
		# The first keypress determines the response time
		if keyboard_response == "" and not erased_answer:
			rt = clock.time() - trial_start_time
		
		if key == "return":
			break
			
		# press 1 for repeating the note
		if key == "1" or key =="backspace":
			if key == "1":
				Sampler(src).play()
			keyboard_response = keyboard_response[:-1]
			# If the answer is completely erased, the RT is no longer informative
			if keyboard_response == "":
				erased_answer = True
				rt = float("inf")
		
		elif key == "space":
			keyboard_response += " "
		
		else:
			keyboard_response += my_keyboard.to_chr(key)
	
		# Update what's on screen'
		my_canvas.clear()
		#my_canvas.text(prompt, font_size = 30)
		if newinst:
			my_canvas.text(answerinst, y = 50, font_size = 20)
		my_canvas.text(keyboard_response, y = 100)
		my_canvas.prepare()
		my_canvas.show()
	
	
	# Check if the response is correct
	correct = keyboard_response == answerinst
	
	# Log response
	response = Response(next_factinst, trial_start_time, rt, correct, "instrument", "mask", "train", keyboard_response)
	m_instruments.register_response(response) 
	
	# Show feedback
	feedback_color = "green" if correct else "red"
	my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	if not correct:
		my_canvas.text(answerinst, y = 150)
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.feedback_duration)
	
	# Clear the screen between trials
	my_canvas.clear()
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.inter_trial_interval)
	
	# Check if time is up
	if clock.time() - var.session_start_time >= var.session_duration:
		var.time_up = True
		
	# Increment trial number
	var.trial_num += 1
	__end__
	set _prepare ""

define inline_script masking_script_2
	set description "Executes Python code"
	___run__
	trial_start_time = clock.time()
	
	# Get next fact from the model
	# next_factinst, newinst = minstruments.get_next_fact(current_time = trial_start_time)
	# promptinst = next_factinst.question
	# answerinst = next_factinst.answer
	
	#next instrument
	next_factinst, newinst = minstruments.get_next_fact(current_time = trial_start_time)
	promptinst = next_factinst.question
	answerinst = next_factinst.answer
	
	
	# Show prompt
	my_canvas = Canvas()
	
	#my_canvas.text(prompt, font_size = 30)
	# we don't want a text prompt, we want a sampler prompt
	# file pool is the folder named __pool__ in this folder
	
	
	# TODO:
	# #OPTIONS FOR MASKING
	# first we want to clear auditory memory by using some noise
	# OPTIION 1 using the synth - terrible, not very effective I think
	# bad_sound = Synth(osc="white_noise", length=800, attack=800, decay=500)
	# bad_sound.volume = 0.25
	# bad_sound.play()
	
	## OPTION 2 - the lick (lol) - right register... but also annoying!
	# can we use different masking sounds in the same set to prevent annoyance?
	'''
	src = pool['mask.wav']
	Sampler(src).play()
	
	# probably too long
	clock.sleep(2000)
	
	'''
	
	src = pool[promptinst+".wav"]
	mysampler =Sampler(src,volume = 0.2)
	mysampler.play()
	#mysampler.wait()
	
	if newinst:
		my_canvas.text(answerinst, y = 50, font_size = 20)
	my_canvas.prepare()
	my_canvas.show()
	
	
	#here we need to add code to give possitive /or negative feedback for the instrument slimpstampen model
	
	
	# Listen for keyboard input and show keypresses on screen as they occur
	my_keyboard = Keyboard()
	keyboard_response = ""
	erased_answer = False
	rt = float("inf")
	
	# Keep listening for key presses until the user presses Enter
	while True:
		key, time = my_keyboard.get_key()
		
		# The first keypress determines the response time
		if keyboard_response == "" and not erased_answer:
			rt = clock.time() - trial_start_time
		
		if key == "return":
			break
			
		# press 1 for repeating the note
		if key == "1" or key =="backspace":
			if key == "1":
				Sampler(src).play()
			keyboard_response = keyboard_response[:-1]
			# If the answer is completely erased, the RT is no longer informative
			if keyboard_response == "":
				erased_answer = True
				rt = float("inf")
		
		elif key == "space":
			keyboard_response += " "
		
		else:
			keyboard_response += my_keyboard.to_chr(key)
	
		# Update what's on screen'
		my_canvas.clear()
		#my_canvas.text(prompt, font_size = 30)
		if newinst:
			my_canvas.text(answerinst, y = 50, font_size = 20)
		my_canvas.text(keyboard_response, y = 100)
		my_canvas.prepare()
		my_canvas.show()
	
	
	# Check if the response is correct
	correct = keyboard_response == answerinst
	
	# Log response
	response = Response(next_factinst, trial_start_time, rt, correct, "instrument", "train")
	minstruments.register_response(response) 
	
	# Show feedback
	feedback_color = "green" if correct else "red"
	my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	if not correct:
		my_canvas.text(answerinst, y = 150)
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.feedback_duration)
	
	# Clear the screen between trials
	my_canvas.clear()
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.inter_trial_interval)
	
	# Check if time is up
	if clock.time() - var.session_start_time >= var.session_duration:
		var.time_up = True
		
	# Increment trial number
	var.trial_num += 1
	__end__
	set _prepare ""

define loop new_loop
	set source_file ""
	set source table
	set repeat 1
	set order random
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if never
	setcycle 0 empty_column ""
	run ""

define inline_script new_mask
	set description "Executes Python code"
	___run__
	run_trial_item(minstruments, "instrument", "mask", "train")
	__end__
	set _prepare ""

define inline_script new_mask_2
	set description "Executes Python code"
	___run__
	run_trial_item(minstruments, "instrument", "mask", "train")
	__end__
	set _prepare ""

define inline_script new_mask_2_1
	set description "Executes Python code"
	___run__
	# run_trial_item(m_instruments, "instrument", "mask", "train")
	__end__
	set _prepare ""

define sequence new_sequence
	set flush_keyboard yes
	set description "Runs a number of items in sequence"

define sequence new_sequence_2
	set flush_keyboard yes
	set description "Runs a number of items in sequence"

define sketchpad new_sketchpad
	set duration keypress
	set description "Displays stimuli"

define inline_script new_test_pitch_mask
	set description "Executes Python code"
	___run__
	def combine_facts_lists(pitch_or_interval_list: list,\
	                        instrument_list: list,\
	                        pitch_or_interval: str):
	    fact_list_to_test = []
	
	    # extra randomizer
	    random.shuffle(pitch_or_interval_list)
	    random.shuffle(instrument_list)
	    
	    n_facts = min(len(pitch_or_interval_list), len(instrument_list))
	
	    for i in range(n_facts):
	        fact_list_to_test.append((instrument_list[i], "instrument"))
	        fact_list_to_test.append((pitch_or_interval_list[i],\
	                                  pitch_or_interval))
	        
	def present_fact(fact, model_package, has_mask, is_test):
	    cue, answer = test_fact
	    
	    if cue_parse_function:
	        cue = cue_parse_function(cue)
	    
	    trial_start_time = clock.time()
	    
	    user_response_dict = ui.present_item(cue, answer, False)
	    results = user_response_dict
	    
	    response = Response(test_fact, trial_start_time, rt, correct, condition, "mask", "test", keyboard_response)
	                        
	        
	    rt = results['time'] - trial_start_time \
		if not results['response_has_been_erased'] \
			else float('inf')
	    		
	    correct = results['correct']
	    user_answer = results['response']
	    
	    response = Response(fact= next_fact, \
	        start_time= trial_start_time, rt= rt, correct= correct, \
	        condition= condition, mask= mask, test= test,\
	        user_answer= user_answer)
	    
	    spacing_model.register_response(response) 
	    
	    clock.sleep(var.feedback_duration)
	    
	    # Clear the screen between trials
	    ui.clear_screen()
	    
	    clock.sleep(var.inter_trial_interval)
	    
	    # Check if time is up
	    if clock.time() - var.session_start_time >= var.session_duration:
	    	var.time_up = True
	    	
	    # Increment trial number
	    var.trial_num += 1
	    
	for fact in fact_list_to_test:
	    present_fact(fact)
	    
	    
	__end__
	set _prepare ""

define inline_script new_trial
	set description "Executes Python code"
	___run__
	run_trial_item(m, "pitch", "mask", "train")
	__end__
	set _prepare ""

define inline_script new_trial_2
	set description "Executes Python code"
	___run__
	run_trial_item(m, "pitch", "no_mask", "train")
	__end__
	set _prepare ""

define inline_script new_trial_3
	set description "Executes Python code"
	___run__
	run_trial_item(m, "pitch", "no_mask", "train")
	__end__
	set _prepare ""

define inline_script new_trial_3_1
	set description "Executes Python code"
	___run__
	run_trial_item(m_relative, "pitch", "no_mask", "train", rp_parse_cue)
	__end__
	set _prepare ""

define inline_script new_trial_4
	set description "Executes Python code"
	___run__
	run_trial_item(m, "relative", "no_mask", "train", rp_parse_cue)
	__end__
	set _prepare ""

define loop pitch_w_mask
	set source_file ""
	set source table
	set repeat 1
	set order sequential
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if never
	setcycle 0 empty_column ""
	run pitch_w_mask_sequence_2

define inline_script pitch_w_mask_learning_script
	set description "Executes Python code"
	set _run "run_masked_learning(instrument_package, pitch_package)"
	set _prepare ""

define inline_script pitch_w_mask_learning_script_1
	set description "Executes Python code"
	set _run "run_unmasked_learning(pitch_package)"
	set _prepare ""

define sequence pitch_w_mask_sequence
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run training_instructions always
	run pitch_w_mask_learning_script always
	run testing_instructions always
	run pitch_w_mask_test_script always

define sequence pitch_w_mask_sequence_2
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run Training_instructions_old always
	run while_there_is_time_left always
	run Testing_instructions_old always
	run new_test_pitch_mask always
	run Testingblock_mask always

define inline_script pitch_w_mask_test_script
	set description "Executes Python code"
	set _run "run_masked_test(instrument_package, pitch_package)"
	set _prepare ""

define inline_script pitch_w_mask_test_script_1
	set description "Executes Python code"
	set _run "run_unmasked_test(pitch_package)"
	set _prepare ""

define loop pitch_while_there_are_items_left
	set source_file ""
	set source table
	set repeat 1
	set order random
	set description "Repeatedly runs another item"
	set cycles 3
	set continuous no
	set break_if_on_first yes
	set break_if "[end] = yes"
	setcycle 0 pitch e3
	setcycle 1 pitch f3
	setcycle 2 pitch g3
	run ""

define sequence pitch_wo_mask_sequence
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run Training_instructions_1 always
	run while_there_is_time_left_1 always
	run Testing_instructions_1 always
	run Testingblock_1 always

define sequence pitch_wo_mask_sequence_1
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run change_group_to_pitch_no_mask always
	run training_instructions always
	run pitch_w_mask_learning_script_1 always
	run testing_instructions always
	run pitch_w_mask_test_script_1 always

define inline_script present_trial
	set description "Executes Python code"
	___run__
	trial_start_time = clock.time()
	
	# Get next fact from the model
	next_fact, new = m.get_next_fact(current_time = trial_start_time)
	prompt = next_fact.question
	answer = next_fact.answer
	
	# #next instrument
	# next_fact, new = minstruments.get_next_fact(current_time = trial_start_time)
	# prompt = next_fact.question
	# answer = next_fact.answer
	
	
	# Show prompt
	my_canvas = Canvas()
	
	#my_canvas.text(prompt, font_size = 30)
	# we don't want a text prompt, we want a sampler prompt
	# file pool is the folder named __pool__ in this folder
	
	
	# TODO:
	# #OPTIONS FOR MASKING
	# first we want to clear auditory memory by using some noise
	# OPTIION 1 using the synth - terrible, not very effective I think
	# bad_sound = Synth(osc="white_noise", length=800, attack=800, decay=500)
	# bad_sound.volume = 0.25
	# bad_sound.play()
	
	## OPTION 2 - the lick (lol) - right register... but also annoying!
	# can we use different masking sounds in the same set to prevent annoyance?
	'''
	src = pool['mask.wav']
	Sampler(src).play()
	
	# probably too long
	clock.sleep(2000)
	
	'''
	
	# src = pool[promptinst+".wav"]
	# Sampler(src).play()
	
	# if newinst:
	# 	my_canvas.text(answerinst, y = 50, font_size = 20)
	# my_canvas.prepare()
	# my_canvas.show()
	
	
	#here we need to add code to give possitive /or negative feedback for the instrument slimpstampen model
	
	#actual note present
	prompt_name = prompt+'.wav'
	src = pool[prompt_name]
	sample = Sampler(src)
	sample.play()
	
	if new:
		my_canvas.text(answer, y = 50, font_size = 20)
	my_canvas.prepare()
	my_canvas.show()
	
	# Listen for keyboard input and show keypresses on screen as they occur
	my_keyboard = Keyboard()
	keyboard_response = ""
	erased_answer = False
	rt = float("inf")
	
	# Keep listening for key presses until the user presses Enter
	while True:
		key, time = my_keyboard.get_key()
		
		# The first keypress determines the response time
		if keyboard_response == "" and not erased_answer:
			rt = clock.time() - trial_start_time
		
		if key == "return":
			break
			
		# press r for repeating the note
		if key == "1" or key == "backspace":
			if key == "1":
				Sampler(src).play()
			keyboard_response = keyboard_response[:-1]
			# If the answer is completely erased, the RT is no longer informative
			if keyboard_response == "":
				erased_answer = True
				rt = float("inf")
		
		elif key == "space":
			keyboard_response += " "
		
		else:
			keyboard_response += my_keyboard.to_chr(key)
	
		# Update what's on screen'
		my_canvas.clear()
		#my_canvas.text(prompt, font_size = 30)
		if new:
			my_canvas.text(answer, y = 50, font_size = 20)
		my_canvas.text(keyboard_response, y = 100)
		my_canvas.prepare()
		my_canvas.show()
	
	
	# Check if the response is correct
	correct = keyboard_response == answer
	
	# Log response
	response = Response(next_fact, trial_start_time, rt, correct, "pitch", "mask", "train", keyboard_response)
	m.register_response(response) 
	
	# Show feedback
	feedback_color = "green" if correct else "red"
	my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	if not correct:
		my_canvas.text(answer, y = 150)
	my_canvas.prepare()
	my_canvas.show()
	
	clock.sleep(var.feedback_duration)
	
	# Clear the screen between trials
	sample.stop()
	my_canvas.clear()
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.inter_trial_interval)
	
	
	# Check if time is up
	if clock.time() - var.session_start_time >= var.session_duration:
		var.time_up = True
		
	# Increment trial number
	var.trial_num += 1
	__end__
	___prepare__
	import numpy as np
	import os
	__end__

define inline_script present_trial_1
	set description "Executes Python code"
	___run__
	trial_start_time = clock.time()
	
	# Get next fact from the model
	next_fact, new = m.get_next_fact(current_time = trial_start_time)
	prompt = next_fact.question
	answer = next_fact.answer
	
	# #next instrument
	# next_fact, new = minstruments.get_next_fact(current_time = trial_start_time)
	# prompt = next_fact.question
	# answer = next_fact.answer
	
	
	# Show prompt
	my_canvas = Canvas()
	
	#my_canvas.text(prompt, font_size = 30)
	# we don't want a text prompt, we want a sampler prompt
	# file pool is the folder named __pool__ in this folder
	
	
	# TODO:
	# #OPTIONS FOR MASKING
	# first we want to clear auditory memory by using some noise
	# OPTIION 1 using the synth - terrible, not very effective I think
	# bad_sound = Synth(osc="white_noise", length=800, attack=800, decay=500)
	# bad_sound.volume = 0.25
	# bad_sound.play()
	
	## OPTION 2 - the lick (lol) - right register... but also annoying!
	# can we use different masking sounds in the same set to prevent annoyance?
	'''
	src = pool['mask.wav']
	Sampler(src).play()
	
	# probably too long
	clock.sleep(2000)
	
	'''
	
	# src = pool[promptinst+".wav"]
	# Sampler(src).play()
	
	# if newinst:
	# 	my_canvas.text(answerinst, y = 50, font_size = 20)
	# my_canvas.prepare()
	# my_canvas.show()
	
	
	#here we need to add code to give possitive /or negative feedback for the instrument slimpstampen model
	
	#actual note present
	prompt_name = prompt+'.wav'
	src = pool[prompt_name]
	sample = Sampler(src)
	sample.play()
	
	if new:
		my_canvas.text(answer, y = 50, font_size = 20)
	my_canvas.prepare()
	my_canvas.show()
	
	# Listen for keyboard input and show keypresses on screen as they occur
	my_keyboard = Keyboard()
	keyboard_response = ""
	erased_answer = False
	rt = float("inf")
	
	# Keep listening for key presses until the user presses Enter
	while True:
		key, time = my_keyboard.get_key()
		
		# The first keypress determines the response time
		if keyboard_response == "" and not erased_answer:
			rt = clock.time() - trial_start_time
		
		if key == "return":
			break
			
		# press r for repeating the note
		if key == "1" or key == "backspace":
			if key == "1":
				Sampler(src).play()
			keyboard_response = keyboard_response[:-1]
			# If the answer is completely erased, the RT is no longer informative
			if keyboard_response == "":
				erased_answer = True
				rt = float("inf")
		
		elif key == "space":
			keyboard_response += " "
		
		else:
			keyboard_response += my_keyboard.to_chr(key)
	
		# Update what's on screen'
		my_canvas.clear()
		#my_canvas.text(prompt, font_size = 30)
		if new:
			my_canvas.text(answer, y = 50, font_size = 20)
		my_canvas.text(keyboard_response, y = 100)
		my_canvas.prepare()
		my_canvas.show()
	
	
	# Check if the response is correct
	correct = keyboard_response == answer
	
	# Log response
	response = Response(next_fact, trial_start_time, rt, correct, "pitch", "no_mask", "train", keyboard_response)
	m.register_response(response) 
	
	# Show feedback
	feedback_color = "green" if correct else "red"
	my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	if not correct:
		my_canvas.text(answer, y = 150)
	my_canvas.prepare()
	my_canvas.show()
	
	clock.sleep(var.feedback_duration)
	
	# Clear the screen between trials
	sample.stop()
	my_canvas.clear()
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.inter_trial_interval)
	
	
	# Check if time is up
	if clock.time() - var.session_start_time >= var.session_duration:
		var.time_up = True
		
	# Increment trial number
	var.trial_num += 1
	__end__
	___prepare__
	import numpy as np
	import os
	__end__

define inline_script present_trial_2
	set description "Executes Python code"
	___run__
	import re
	
	trial_start_time = clock.time()
	
	# Get next fact from the model
	next_fact, new = m_relative.get_next_fact(current_time = trial_start_time)
	second_note = next_fact.question
	first_note = 0
	answer = str(next_fact.answer)
	
	
	all_notes = ['a3', 'a-3', 'b3', 'c3', 'c-3', 'd3', 'd-3', 'e3', 'f3', 'f-3', 'g3', 'g-3',
	                 'a4', 'a-4', 'b4', 'c4', 'c-4', 'd4', 'd-4', 'e4', 'f4', 'f-4', 'g4', 'g-4',
	                 'a5', 'a-5', 'b5', 'c5', 'c-5', 'd5', 'd-5', 'e5', 'f5', 'f-5', 'g5', 'g-5']
	
	
	  # interval is ascending so we need to start low:
	first_list = ['a3', 'a-3', 'b3', 'c3', 'c-3', 'd3', 'd-3', 'e3', 'f3', 'f-3', 'g3', 'g-3',
	                 'a4', 'a-4', 'b4', 'c4', 'c-4', 'd4', 'd-4', 'e4', 'f4', 'f-4', 'g4', 'g-4']
	asc = 1
	
	
	first_note_instant = random.choice(first_list)
	print(first_note_instant)
	print(first_note, second_note)
	
	index_first_note = all_notes.index(first_note_instant)
	print(index_first_note)
	if str("octave") in answer:
		index_second_note = index_first_note + asc*12
	else:
		index_second_note = index_first_note + int(second_note)
	print(index_second_note)
		
		
	second_note_instant = all_notes[index_second_note]
	print(second_note_instant)
	print(answer)
	
	
			
	# #next instrument
	# next_fact, new = minstruments.get_next_fact(current_time = trial_start_time)
	# prompt = next_fact.question
	# answer = next_fact.answer
	
	
	# Show prompt
	my_canvas = Canvas()
	
	 
	src = pool[first_note_instant+'.wav']
	Sampler(src).play()
	
	clock.sleep(1000)
	
	src = pool[second_note_instant+'.wav']
	Sampler(src).play()
	
	if new:
		my_canvas.text(answer, y = 50, font_size = 20)
	my_canvas.prepare()
	my_canvas.show()
	
	# Listen for keyboard input and show keypresses on screen as they occur
	my_keyboard = Keyboard()
	keyboard_response = ""
	erased_answer = False
	rt = float("inf")
	
	# Keep listening for key presses until the user presses Enter
	while True:
		key, time = my_keyboard.get_key()
		
		# The first keypress determines the response time
		if keyboard_response == "" and not erased_answer:
			rt = clock.time() - trial_start_time
		
		if key == "return":
			break
			
		# press r for repeating the note
		if key == "1" or key == "backspace":
			if key == "1":
				src = pool[first_note_instant+'.wav']
				Sampler(src).play()
	
				clock.sleep(1000)
	
				src = pool[second_note_instant+'.wav']
				Sampler(src).play()
			keyboard_response = keyboard_response[:-1]
			# If the answer is completely erased, the RT is no longer informative
			if keyboard_response == "":
				erased_answer = True
				rt = float("inf")
		
		elif key == "space":
			keyboard_response += " "
		
		else:
			keyboard_response += my_keyboard.to_chr(key)
	
		# Update what's on screen'
		my_canvas.clear()
		#my_canvas.text(prompt, font_size = 30)
		if new:
			my_canvas.text(answer, y = 50, font_size = 20)
		my_canvas.text(keyboard_response, y = 100)
		my_canvas.prepare()
		my_canvas.show()
	
	print(r'%s' %keyboard_response)
	print(r'%s' %answer)
	
	
	regex = re.compile('[^a-z]')
	print(regex.sub('', keyboard_response))
	print(regex.sub('', answer))
	# Check if the response is correct
	correct = regex.sub('', keyboard_response) == regex.sub('', answer)
	
	# Log response
	response = Response(next_fact, trial_start_time, rt, correct, "relative", "mask", "train", regex.sub('', keyboard_response))
	m_relative.register_response(response) 
	
	# Show feedback
	feedback_color = "green" if correct else "red"
	my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	if not correct:
		my_canvas.text(answer, y = 150)
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.feedback_duration)
	
	# Clear the screen between trials
	
	my_canvas.clear()
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.inter_trial_interval)
	
	# Check if time is up
	if clock.time() - var.session_start_time >= var.session_duration:
		var.time_up = True
		
	# Increment trial number
	var.trial_num += 1
	__end__
	___prepare__
	import numpy as np
	import os
	__end__

define inline_script present_trial_2_1
	set description "Executes Python code"
	___run__
	import re
	
	trial_start_time = clock.time()
	
	# Get next fact from the model
	next_fact, new = m_relative.get_next_fact(current_time = trial_start_time)
	second_note = next_fact.question
	first_note = 0
	answer = str(next_fact.answer)
	
	
	all_notes = ['a3', 'a-3', 'b3', 'c3', 'c-3', 'd3', 'd-3', 'e3', 'f3', 'f-3', 'g3', 'g-3',
	                 'a4', 'a-4', 'b4', 'c4', 'c-4', 'd4', 'd-4', 'e4', 'f4', 'f-4', 'g4', 'g-4',
	                 'a5', 'a-5', 'b5', 'c5', 'c-5', 'd5', 'd-5', 'e5', 'f5', 'f-5', 'g5', 'g-5']
	
	
	first_list = ['a3', 'a-3', 'b3', 'c3', 'c-3', 'd3', 'd-3', 'e3', 'f3', 'f-3', 'g3', 'g-3',
	                 'a4', 'a-4', 'b4', 'c4', 'c-4', 'd4', 'd-4', 'e4', 'f4', 'f-4', 'g4', 'g-4']
	asc = 1
	
	
	first_note_instant = random.choice(first_list)
	print(first_note_instant)
	print(first_note, second_note)
	
	index_first_note = all_notes.index(first_note_instant)
	print(index_first_note)
	if str("octave") in answer:
		index_second_note = index_first_note + asc*12
	else:
		index_second_note = index_first_note + int(second_note)
			
		
		
	second_note_instant = all_notes[index_second_note]
	print(second_note_instant)
	print(answer)
	
	
			
	# #next instrument
	# next_fact, new = minstruments.get_next_fact(current_time = trial_start_time)
	# prompt = next_fact.question
	# answer = next_fact.answer
	
	
	# Show prompt
	my_canvas = Canvas()
	
	 
	src = pool[first_note_instant+'.wav']
	Sampler(src).play()
	
	clock.sleep(1000)
	
	src = pool[second_note_instant+'.wav']
	Sampler(src).play()
	
	if new:
		my_canvas.text(answer, y = 50, font_size = 20)
		
	
	my_canvas.prepare()
	my_canvas.show()
	
	# Listen for keyboard input and show keypresses on screen as they occur
	my_keyboard = Keyboard()
	keyboard_response = ""
	erased_answer = False
	rt = float("inf")
	
	# Keep listening for key presses until the user presses Enter
	while True:
		key, time = my_keyboard.get_key()
		
		# The first keypress determines the response time
		if keyboard_response == "" and not erased_answer:
			rt = clock.time() - trial_start_time
		
		if key == "return":
			break
			
		# press r for repeating the note
		if key == "1" or key == "backspace":
			if key == "1":
				src = pool[first_note_instant+'.wav']
				Sampler(src).play()
	
				clock.sleep(1000)
	
				src = pool[second_note_instant+'.wav']
				Sampler(src).play()
			keyboard_response = keyboard_response[:-1]
			# If the answer is completely erased, the RT is no longer informative
			if keyboard_response == "":
				erased_answer = True
				rt = float("inf")
		
		elif key == "space":
			keyboard_response += " "
		
		else:
			keyboard_response += my_keyboard.to_chr(key)
	
		# Update what's on screen'
		my_canvas.clear()
		#my_canvas.text(prompt, font_size = 30)
		if new:
			my_canvas.text(answer, y = 50, font_size = 20)
		my_canvas.text(keyboard_response, y = 100)
		my_canvas.prepare()
		my_canvas.show()
	
	print(r'%s' %keyboard_response)
	print(r'%s' %answer)
	
	
	regex = re.compile('[^a-z]')
	print(regex.sub('', keyboard_response))
	print(regex.sub('', answer))
	# Check if the response is correct
	correct = regex.sub('', keyboard_response) == regex.sub('', answer)
	
	# Log response
	response = Response(next_fact, trial_start_time, rt, correct, "relative", "no_mask", "train", regex.sub('', keyboard_response))
	m_relative.register_response(response) 
	
	# Show feedback
	feedback_color = "green" if correct else "red"
	my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	if not correct:
		my_canvas.text(answer, y = 150)
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.feedback_duration)
	
	# Clear the screen between trials
	
	my_canvas.clear()
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.inter_trial_interval)
	
	# Check if time is up
	if clock.time() - var.session_start_time >= var.session_duration:
		var.time_up = True
		
	# Increment trial number
	var.trial_num += 1
	__end__
	___prepare__
	import numpy as np
	import os
	__end__

define inline_script present_trial_2_2
	set description "Executes Python code"
	___run__
	import re
	
	trial_start_time = clock.time()
	
	# Get next fact from the model
	next_fact, new = m_relative.get_next_fact(current_time = trial_start_time)
	second_note = next_fact.question
	first_note = 0
	answer = str(next_fact.answer)
	
	
	all_notes = ['a3', 'a-3', 'b3', 'c3', 'c-3', 'd3', 'd-3', 'e3', 'f3', 'f-3', 'g3', 'g-3',
	                 'a4', 'a-4', 'b4', 'c4', 'c-4', 'd4', 'd-4', 'e4', 'f4', 'f-4', 'g4', 'g-4',
	                 'a5', 'a-5', 'b5', 'c5', 'c-5', 'd5', 'd-5', 'e5', 'f5', 'f-5', 'g5', 'g-5']
	
	
	  # interval is ascending so we need to start low:
	first_list = ['a3', 'a-3', 'b3', 'c3', 'c-3', 'd3', 'd-3', 'e3', 'f3', 'f-3', 'g3', 'g-3',
	                 'a4', 'a-4', 'b4', 'c4', 'c-4', 'd4', 'd-4', 'e4', 'f4', 'f-4', 'g4', 'g-4']
	asc = 1
	
	
	first_note_instant = random.choice(first_list)
	print(first_note_instant)
	print(first_note, second_note)
	
	index_first_note = all_notes.index(first_note_instant)
	print(index_first_note)
	if str("octave") in answer:
		index_second_note = index_first_note + asc*12
	else:
		index_second_note = index_first_note + int(second_note)
	print(index_second_note)
		
		
	second_note_instant = all_notes[index_second_note]
	print(second_note_instant)
	print(answer)
	
	
			
	# #next instrument
	# next_fact, new = minstruments.get_next_fact(current_time = trial_start_time)
	# prompt = next_fact.question
	# answer = next_fact.answer
	
	
	# Show prompt
	my_canvas = Canvas()
	
	 
	src = pool[first_note_instant+'.wav']
	Sampler(src).play()
	
	clock.sleep(1000)
	
	src = pool[second_note_instant+'.wav']
	Sampler(src).play()
	
	if new:
		my_canvas.text(answer, y = 50, font_size = 20)
	my_canvas.prepare()
	my_canvas.show()
	
	# Listen for keyboard input and show keypresses on screen as they occur
	my_keyboard = Keyboard()
	keyboard_response = ""
	erased_answer = False
	rt = float("inf")
	
	# Keep listening for key presses until the user presses Enter
	while True:
		key, time = my_keyboard.get_key()
		
		# The first keypress determines the response time
		if keyboard_response == "" and not erased_answer:
			rt = clock.time() - trial_start_time
		
		if key == "return":
			break
			
		# press r for repeating the note
		if key == "1" or key == "backspace":
			if key == "1":
				src = pool[first_note_instant+'.wav']
				Sampler(src).play()
	
				clock.sleep(1000)
	
				src = pool[second_note_instant+'.wav']
				Sampler(src).play()
			keyboard_response = keyboard_response[:-1]
			# If the answer is completely erased, the RT is no longer informative
			if keyboard_response == "":
				erased_answer = True
				rt = float("inf")
		
		elif key == "space":
			keyboard_response += " "
		
		else:
			keyboard_response += my_keyboard.to_chr(key)
	
		# Update what's on screen'
		my_canvas.clear()
		#my_canvas.text(prompt, font_size = 30)
		if new:
			my_canvas.text(answer, y = 50, font_size = 20)
		my_canvas.text(keyboard_response, y = 100)
		my_canvas.prepare()
		my_canvas.show()
	
	print(r'%s' %keyboard_response)
	print(r'%s' %answer)
	
	
	regex = re.compile('[^a-z]')
	print(regex.sub('', keyboard_response))
	print(regex.sub('', answer))
	# Check if the response is correct
	correct = regex.sub('', keyboard_response) == regex.sub('', answer)
	
	# Log response
	response = Response(next_fact, trial_start_time, rt, correct, "relative", "mask", "train", regex.sub('', keyboard_response))
	m_relative.register_response(response) 
	
	# Show feedback
	feedback_color = "green" if correct else "red"
	my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	if not correct:
		my_canvas.text(answer, y = 150)
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.feedback_duration)
	
	# Clear the screen between trials
	
	my_canvas.clear()
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.inter_trial_interval)
	
	# Check if time is up
	if clock.time() - var.session_start_time >= var.session_duration:
		var.time_up = True
		
	# Increment trial number
	var.trial_num += 1
	__end__
	___prepare__
	import numpy as np
	import os
	__end__

define inline_script save_data
	set description "Executes Python code"
	___run__
	# Write the SlimStampen data to the OpenSesame log file
	dat = pitch_package.spacing_model.export_data(header_true=True)
	dat2 = instrument_package.spacing_model.export_data(header_true = False)
	dat3 = interval_package.spacing_model.export_data(header_true = False)
	log.write(dat)
	log.write(dat2)
	log.write(dat3)
	__end__
	set _prepare ""

define inline_script slimstampen_setup
	set description "Executes Python code"
	___run__
	m = SpacingModel()
	m_instruments = SpacingModel()
	m_relative = SpacingModel()
	__end__
	___prepare__
	from __future__ import division
	import math
	import pandas as pd
	from collections import namedtuple
	
	Fact = namedtuple("Fact", "fact_id, question, answer")
	Response = namedtuple("Response", "fact, start_time, rt, correct, condition, mask, test, user_answer")
	Encounter = namedtuple("Encounter", "activation, time, reaction_time, decay")
	
	
	class SpacingModel(object):
	
	    # Model constants
	    LOOKAHEAD_TIME = 15000
	    FORGET_THRESHOLD = -0.8
	    DEFAULT_ALPHA = 0.3
	    C = 0.25
	    F = 1.0
	
	    def __init__(self):
	        self.facts = []
	        self.responses = []
	
	    def add_fact(self, fact):
	        # type: (Fact) -> None
	        """
	        Add a fact to the list of study items.
	        """
	        # Ensure that a fact with this ID does not exist already
	        if next((f for f in self.facts if f.fact_id == fact.fact_id), None):
	            raise RuntimeError(
	                "Error while adding fact: There is already a fact with the same ID: {}. Each fact must have a unique ID".format(fact.fact_id))
	
	        self.facts.append(fact)
	
	
	    def register_response(self, response):
	        # type: (Response) -> None
	        """
	        Register a response.
	        """
	        # Prevent duplicate responses
	        if next((r for r in self.responses if r.start_time == response.start_time), None):
	            raise RuntimeError(
	                "Error while registering response: A response has already been logged at this start_time: {}. Each response must occur at a unique start_time.".format(response.start_time))
	
	        self.responses.append(response)
	
	
	    def get_next_fact(self, current_time):
	        # type: (int) -> (Fact, bool)
	        """
	        Returns a tuple containing the fact that needs to be repeated most urgently and a boolean indicating whether this fact is new (True) or has been presented before (False).
	        If none of the previously studied facts needs to be repeated right now, return a new fact instead.
	        """
	        # Calculate all fact activations in the near future
	        fact_activations = [(f, self.calculate_activation(current_time + self.LOOKAHEAD_TIME, f)) for f in self.facts]
	
	        seen_facts = [(f, a) for (f, a) in fact_activations if a > -float("inf")]
	        not_seen_facts = [(f, a) for (f, a) in fact_activations if a == -float("inf")]
	
	        # Prevent an immediate repetition of the same fact
	        if len(seen_facts) > 2:
	            last_response = self.responses[-1]
	            seen_facts = [(f, a) for (f, a) in seen_facts if f.fact_id != last_response.fact.fact_id]
	
	        # Reinforce the weakest fact with an activation below the threshold
	        seen_facts_below_threshold = [(f, a) for (f, a) in seen_facts if a < self.FORGET_THRESHOLD]
	        if len(not_seen_facts) == 0 or len(seen_facts_below_threshold) > 0:
	            weakest_fact = min(seen_facts, key = lambda t: t[1])
	            return((weakest_fact[0], False))
	
	        # If none of the previously seen facts has an activation below the threshold, return a new fact
	        return((not_seen_facts[0][0], True))
	
	
	    def get_rate_of_forgetting(self, time, fact):
	        # type: (int, Fact) -> float
	        """
	        Return the estimated rate of forgetting of the fact at the specified time
	        """
	        encounters = []
	
	        responses_for_fact = [r for r in self.responses if r.fact.fact_id == fact.fact_id and r.start_time < time]
	        alpha = self.DEFAULT_ALPHA
	
	        # Calculate the activation by running through the sequence of previous responses
	        for response in responses_for_fact:
	            activation = self.calculate_activation_from_encounters(encounters, response.start_time)
	            encounters.append(Encounter(activation, response.start_time, self.normalise_reaction_time(response), self.DEFAULT_ALPHA))
	            alpha = self.estimate_alpha(encounters, activation, response, alpha)
	
	            # Update decay estimates of previous encounters
	            encounters = [encounter._replace(decay = self.calculate_decay(encounter.activation, alpha)) for encounter in encounters]
	
	        return(alpha)
	
	
	    def calculate_activation(self, time, fact):
	        # type: (int, Fact) -> float
	        """
	        Calculate the activation of a fact at the given time.
	        """
	
	        encounters = []
	
	        responses_for_fact = [r for r in self.responses if r.fact.fact_id == fact.fact_id and r.start_time < time]
	        alpha = self.DEFAULT_ALPHA
	
	        # Calculate the activation by running through the sequence of previous responses
	        for response in responses_for_fact:
	            activation = self.calculate_activation_from_encounters(encounters, response.start_time)
	            encounters.append(Encounter(activation, response.start_time, self.normalise_reaction_time(response), self.DEFAULT_ALPHA))
	            alpha = self.estimate_alpha(encounters, activation, response, alpha)
	
	            # Update decay estimates of previous encounters
	            encounters = [encounter._replace(decay = self.calculate_decay(encounter.activation, alpha)) for encounter in encounters]
	
	        return(self.calculate_activation_from_encounters(encounters, time))
	
	
	    def calculate_decay(self, activation, alpha):
	        # type: (float, float) -> float
	        """
	        Calculate activation-dependent decay
	        """
	        return self.C * math.exp(activation) + alpha
	
	
	    def estimate_alpha(self, encounters, activation, response, previous_alpha):
	        # type: ([Encounter], float, Response, float) -> float
	        """
	        Estimate the rate of forgetting parameter (alpha) for an item.
	        """
	        if len(encounters) < 3:
	            return(self.DEFAULT_ALPHA)
	
	        a_fit = previous_alpha
	        reading_time = self.get_reading_time(response.fact.question)
	        estimated_rt = self.estimate_reaction_time_from_activation(activation, reading_time)
	        est_diff = estimated_rt - self.normalise_reaction_time(response)
	
	        if est_diff < 0:
	            # Estimated RT was too short (estimated activation too high), so actual decay was larger
	            a0 = a_fit
	            a1 = a_fit + 0.05
	        
	        else:
	            # Estimated RT was too long (estimated activation too low), so actual decay was smaller
	            a0 = a_fit - 0.05
	            a1 = a_fit
	
	        # Binary search between previous fit and proposed alpha
	        for _ in range(6):
	            # Adjust all decays to use the new alpha
	            a0_diff = a0 - a_fit
	            a1_diff = a1 - a_fit
	            d_a0 = [e._replace(decay = e.decay + a0_diff) for e in encounters]
	            d_a1 = [e._replace(decay = e.decay + a1_diff) for e in encounters]
	
	            # Calculate the reaction times from activation and compare against observed RTs
	            encounter_window = encounters[max(1, len(encounters) - 5):]
	            total_a0_error = self.calculate_predicted_reaction_time_error(encounter_window, d_a0, reading_time)
	            total_a1_error = self.calculate_predicted_reaction_time_error(encounter_window, d_a1, reading_time)
	
	            # Adjust the search area based on the lowest total error
	            ac = (a0 + a1) / 2
	            if total_a0_error < total_a1_error:
	                a1 = ac
	            else:
	                a0 = ac
	        
	        # The new alpha estimate is the average value in the remaining bracket
	        return((a0 + a1) / 2)
	
	
	    def calculate_activation_from_encounters(self, encounters, current_time):
	        # type: ([Encounter], int) -> float
	        included_encounters = [e for e in encounters if e.time < current_time]
	
	        if len(included_encounters) == 0:
	            return(-float("inf"))
	
	        return(math.log(sum([math.pow((current_time - e.time) / 1000, -e.decay) for e in included_encounters])))
	
	
	    def calculate_predicted_reaction_time_error(self, test_set, decay_adjusted_encounters, reading_time):
	        # type: ([Encounter], [Encounter], Fact) -> float
	        """
	        Calculate the summed absolute difference between observed response times and those predicted based on a decay adjustment.
	        """
	        activations = [self.calculate_activation_from_encounters(decay_adjusted_encounters, e.time - 100) for e in test_set]
	        rt = [self.estimate_reaction_time_from_activation(a, reading_time) for a in activations]
	        rt_errors = [abs(e.reaction_time - rt) for (e, rt) in zip(test_set, rt)]
	        return(sum(rt_errors))
	
	
	    def estimate_reaction_time_from_activation(self, activation, reading_time):
	        # type: (float, int) -> float
	        """
	        Calculate an estimated reaction time given a fact's activation and the expected reading time 
	        """
	        return((self.F * math.exp(-activation) + (reading_time / 1000)) * 1000)
	
	
	    def get_max_reaction_time_for_fact(self, fact):
	        # type: (Fact) -> float
	        """
	        Return the highest response time we can reasonably expect for a given fact
	        """
	        reading_time = self.get_reading_time(fact.question)
	        max_rt = 1.5 * self.estimate_reaction_time_from_activation(self.FORGET_THRESHOLD, reading_time)
	        return(max_rt)
	
	
	    def get_reading_time(self, text):
	        # type: (str) -> float
	        """
	        Return expected reading time in milliseconds for a given string
	        """
	        return 0.0
	        word_count = len(text.split())
	
	        if word_count > 1:
	            character_count = len(text)
	            return(max((-157.9 + character_count * 19.5), 300))
	        
	        return(300)
	
	    
	    def normalise_reaction_time(self, response):
	        # type: (Response) -> float
	        """
	        Cut off extremely long responses to keep the reaction time within reasonable bounds
	        """
	        rt = response.rt if response.correct else 60000
	        max_rt = self.get_max_reaction_time_for_fact(response.fact)
	        return(min(rt, max_rt))
	
	
	    def export_data(self, path = None, header_true = True):
	        # type: (str) -> DataFrame
	        """
	        Save the response data to the specified csv file, and return a copy of the pandas DataFrame.
	        If no path is specified, return a CSV-formatted copy of the data instead.
	        """
	
	        def calc_rof(row):
	            return(self.get_rate_of_forgetting(row["start_time"] + 1, row["fact"]))
	
	        dat_resp = pd.DataFrame(self.responses)
	        dat_facts = pd.DataFrame([r.fact for r in self.responses])
	        dat = pd.concat([dat_resp, dat_facts], axis = 1)
	
	        # Add column for rate of forgetting estimate after each observation
	        dat["alpha"] = dat.apply(calc_rof, axis = 1)
	        dat.drop(columns = "fact", inplace = True)
	
	        # Add trial number column
	        dat.index.name = "trial"
	        dat.index = dat.index + 1
	            
	
	        # Save to CSV file if a path was specified, otherwise return the CSV-formatted output
	        if path is not None:
	            dat.to_csv(path, header=header_true, encoding="UTF-8")
	            return(dat)
	        
	        return(dat.to_csv(header=header_true))
	__end__

define sketchpad switching_to_intervals
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Now starting Interval conditions" x=0 y=0 z_index=0

define sketchpad testing_instructions
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=white font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Testing phase begins now<br />Press any key to continue<br /><br />" x=0 y=0 z_index=0

define sketchpad training_instructions
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color="#fec52d" font_bold=no font_family=mono font_italic=no font_size=18 html=yes show_if=always text="Starting training block... <br />press any key to continue, when you're ready" x=0.0 y=0.0 z_index=0

define sequence trial_sequence
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run new_mask always
	run new_trial always
	run masking_script always
	run present_trial always

define sequence trial_sequence_1
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run new_trial_2 always
	run present_trial_1 always

define sequence trial_sequence_2
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run new_mask_2 always
	run new_trial_3 always
	run masking_script_1 always
	run present_trial_2 always

define sequence trial_sequence_2_1
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run new_trial_4 always
	run present_trial_2_1 always

define sequence trial_sequence_2_2
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run new_mask_2_1 always
	run new_trial_3_1 always
	run masking_script_1_2 always
	run present_trial_2_2 always

define loop while_there_is_time_left
	set source table
	set repeat 1000
	set order random
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if "[time_up] = yes"
	setcycle 0 ignore_this_variable 1
	run trial_sequence

define loop while_there_is_time_left_1
	set source table
	set repeat 1000
	set order random
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if "[time_up] = yes"
	setcycle 0 ignore_this_variable 1
	run trial_sequence_1

define loop while_there_is_time_left_2
	set source table
	set repeat 1000
	set order random
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if "[time_up] = yes"
	setcycle 0 ignore_this_variable 1
	run trial_sequence_2

define loop while_there_is_time_left_2_1
	set source table
	set repeat 1000
	set order random
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if "[time_up] = yes"
	setcycle 0 ignore_this_variable 1
	run trial_sequence_2_1

define loop while_there_is_time_left_2_2
	set source table
	set repeat 1000
	set order random
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if "[time_up] = yes"
	setcycle 0 ignore_this_variable 1
	run interval_w_mask_script

